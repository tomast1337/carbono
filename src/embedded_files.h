#ifndef EMBEDDED_FILES_H
#define EMBEDDED_FILES_H

const char *SRC_BASALTO_H = "#ifndef BASALTO_CORE_H\n#define BASALTO_CORE_H\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n#include <dlfcn.h>\n#include \"sds.h\"\n#include \"stb_ds.h\"\n\n// Macro must be in header so it expands in the user code\n#define print_any(x) _Generic((x), \\\n    int: \"%d\", \\\n    long: \"%ld\", \\\n    long long: \"%lld\", \\\n    unsigned int: \"%u\", \\\n    unsigned long: \"%lu\", \\\n    short: \"%hd\", \\\n    float: \"%f\", \\\n    double: \"%lf\", \\\n    char*: \"%s\", \\\n    char: \"%c\", \\\n    default: \"%d\")\n\n// Input\nvoid flush_input();\nint read_int();\nlong long read_long();\nfloat read_float();\ndouble read_double();\nchar* read_string();\nvoid wait_enter();\n\n// Conversions\nsds int8_to_string(signed char x);\nsds int16_to_string(short x);\nsds int32_to_string(int x);\nsds int64_to_string(long long x);\nsds int_arq_to_string(long x);\nsds float32_to_string(float x);\nsds float64_to_string(double x);\nsds float_ext_to_string(long double x);\nsds char_to_string(char* x);\nsds array_int_to_string(int* arr);\nsds array_string_to_string(char** arr);\n\n// String Parsing\nsigned char string_to_int8(char* s);\nshort string_to_int16(char* s);\nint string_to_int32(char* s);\nlong long string_to_int64(char* s);\nlong string_to_int_arq(char* s);\nfloat string_to_real32(char* s);\ndouble string_to_real64(char* s);\nlong double string_to_real_ext(char* s);\n\n// --- MEMORY MANAGEMENT (Arena) ---\nvoid* bs_alloc(size_t size);\nvoid bs_free_all();\n\n#endif\n";

const char *SRC_CORE_C = "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdarg.h>\n\n#define STB_DS_IMPLEMENTATION\n#include \"stb_ds.h\"\n#include \"sds.h\"\n\n// --- ARENA MEMORY MANAGER ---\ntypedef struct Allocation {\n    void* ptr;\n    struct Allocation* next;\n} Allocation;\n\nstatic Allocation* arena_head = NULL;\n\nvoid* bs_alloc(size_t size) {\n    // 1. Allocate object (zero-initialized)\n    void* ptr = calloc(1, size);\n    if (!ptr) {\n        fprintf(stderr, \"[Basalto] Out of memory!\\n\");\n        exit(1);\n    }\n\n    // 2. Track it\n    Allocation* node = malloc(sizeof(Allocation));\n    if (!node) {\n        free(ptr);\n        fprintf(stderr, \"[Basalto] Out of memory (tracker)!\\n\");\n        exit(1);\n    }\n    node->ptr = ptr;\n    node->next = arena_head;\n    \n    // 3. Link it\n    arena_head = node;\n    \n    return ptr;\n}\n\nvoid bs_free_all() {\n    Allocation* current = arena_head;\n    while (current) {\n        Allocation* next = current->next;\n        free(current->ptr);\n        free(current);\n        current = next;\n    }\n    arena_head = NULL;\n}\n\n// --- INPUT HELPERS ---\n\nvoid flush_input() { \n    int c; \n    while ((c = getchar()) != '\\n' && c != EOF); \n}\n\nint read_int() { \n    int x; \n    scanf(\"%d\", &x); \n    flush_input(); \n    return x; \n}\n\nlong long read_long() { \n    long long x; \n    scanf(\"%lld\", &x); \n    flush_input(); \n    return x; \n}\n\nfloat read_float() { \n    float x; \n    scanf(\"%f\", &x); \n    flush_input(); \n    return x; \n}\n\ndouble read_double() { \n    double x; \n    scanf(\"%lf\", &x); \n    flush_input(); \n    return x; \n}\n\nchar* read_string() { \n    sds s = sdsempty(); \n    int c; \n    while((c=getchar())!='\\n' && c!=EOF) { \n        char ch=c; \n        s=sdscatlen(s,&ch,1); \n    } \n    return s; \n}\n\nvoid wait_enter() { \n    flush_input(); \n}\n\n// --- CONVERSION HELPERS ---\n\nsds int8_to_string(signed char x) { return sdscatprintf(sdsempty(), \"%d\", x); }\nsds int16_to_string(short x) { return sdscatprintf(sdsempty(), \"%d\", x); }\nsds int32_to_string(int x) { return sdscatprintf(sdsempty(), \"%d\", x); }\nsds int64_to_string(long long x) { return sdscatprintf(sdsempty(), \"%lld\", x); }\nsds int_arq_to_string(long x) { return sdscatprintf(sdsempty(), \"%ld\", x); }\nsds float32_to_string(float x) { return sdscatprintf(sdsempty(), \"%f\", x); }\nsds float64_to_string(double x) { return sdscatprintf(sdsempty(), \"%f\", x); }\nsds float_ext_to_string(long double x) { return sdscatprintf(sdsempty(), \"%Lf\", x); }\nsds char_to_string(char* x) { return sdsnew(x); }\n\nsds array_int_to_string(int* arr) {\n    if (!arr || arrlen(arr) == 0) return sdsnew(\"[]\");\n    sds result = sdsnew(\"[\");\n    for (int i = 0; i < arrlen(arr); i++) {\n        if (i > 0) result = sdscat(result, \", \");\n        result = sdscatprintf(result, \"%d\", arr[i]);\n    }\n    result = sdscat(result, \"]\");\n    return result;\n}\n\nsds array_string_to_string(char** arr) {\n    if (!arr || arrlen(arr) == 0) return sdsnew(\"[]\");\n    sds result = sdsnew(\"[\");\n    for (int i = 0; i < arrlen(arr); i++) {\n        if (i > 0) result = sdscat(result, \", \");\n        result = sdscat(result, \"\\\"\");\n        if (arr[i]) result = sdscat(result, arr[i]);\n        result = sdscat(result, \"\\\"\");\n    }\n    result = sdscat(result, \"]\");\n    return result;\n}\n\n// --- STRING TO PRIMITIVE ---\n\nsigned char string_to_int8(char* s) { return (signed char)atoi(s); }\nshort string_to_int16(char* s) { return (short)atoi(s); }\nint string_to_int32(char* s) { return atoi(s); }\nlong long string_to_int64(char* s) { return atoll(s); }\nlong string_to_int_arq(char* s) { return atol(s); }\nfloat string_to_real32(char* s) { return (float)atof(s); }\ndouble string_to_real64(char* s) { return atof(s); }\nlong double string_to_real_ext(char* s) { return (long double)atof(s); }\n";

const char *SRC_SDS_H = "/* SDSLib 2.0 -- A C dynamic strings library\n *\n * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>\n * Copyright (c) 2015, Oran Agra\n * Copyright (c) 2015, Redis Labs, Inc\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#ifndef __SDS_H\n#define __SDS_H\n\n#define SDS_MAX_PREALLOC (1024*1024)\nextern const char *SDS_NOINIT;\n\n#include <sys/types.h>\n#include <stdarg.h>\n#include <stdint.h>\n\ntypedef char *sds;\n\n/* Note: sdshdr5 is never used, we just access the flags byte directly.\n * However is here to document the layout of type 5 SDS strings. */\nstruct __attribute__ ((__packed__)) sdshdr5 {\n    unsigned char flags; /* 3 lsb of type, and 5 msb of string length */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr8 {\n    uint8_t len; /* used */\n    uint8_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr16 {\n    uint16_t len; /* used */\n    uint16_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr32 {\n    uint32_t len; /* used */\n    uint32_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\nstruct __attribute__ ((__packed__)) sdshdr64 {\n    uint64_t len; /* used */\n    uint64_t alloc; /* excluding the header and null terminator */\n    unsigned char flags; /* 3 lsb of type, 5 unused bits */\n    char buf[];\n};\n\n#define SDS_TYPE_5  0\n#define SDS_TYPE_8  1\n#define SDS_TYPE_16 2\n#define SDS_TYPE_32 3\n#define SDS_TYPE_64 4\n#define SDS_TYPE_MASK 7\n#define SDS_TYPE_BITS 3\n#define SDS_HDR_VAR(T,s) struct sdshdr##T *sh = (void*)((s)-(sizeof(struct sdshdr##T)));\n#define SDS_HDR(T,s) ((struct sdshdr##T *)((s)-(sizeof(struct sdshdr##T))))\n#define SDS_TYPE_5_LEN(f) ((f)>>SDS_TYPE_BITS)\n\nstatic inline size_t sdslen(const sds s) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            return SDS_TYPE_5_LEN(flags);\n        case SDS_TYPE_8:\n            return SDS_HDR(8,s)->len;\n        case SDS_TYPE_16:\n            return SDS_HDR(16,s)->len;\n        case SDS_TYPE_32:\n            return SDS_HDR(32,s)->len;\n        case SDS_TYPE_64:\n            return SDS_HDR(64,s)->len;\n    }\n    return 0;\n}\n\nstatic inline size_t sdsavail(const sds s) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5: {\n            return 0;\n        }\n        case SDS_TYPE_8: {\n            SDS_HDR_VAR(8,s);\n            return sh->alloc - sh->len;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            return sh->alloc - sh->len;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            return sh->alloc - sh->len;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            return sh->alloc - sh->len;\n        }\n    }\n    return 0;\n}\n\nstatic inline void sdssetlen(sds s, size_t newlen) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            {\n                unsigned char *fp = ((unsigned char*)s)-1;\n                *fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS);\n            }\n            break;\n        case SDS_TYPE_8:\n            SDS_HDR(8,s)->len = newlen;\n            break;\n        case SDS_TYPE_16:\n            SDS_HDR(16,s)->len = newlen;\n            break;\n        case SDS_TYPE_32:\n            SDS_HDR(32,s)->len = newlen;\n            break;\n        case SDS_TYPE_64:\n            SDS_HDR(64,s)->len = newlen;\n            break;\n    }\n}\n\nstatic inline void sdsinclen(sds s, size_t inc) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            {\n                unsigned char *fp = ((unsigned char*)s)-1;\n                unsigned char newlen = SDS_TYPE_5_LEN(flags)+inc;\n                *fp = SDS_TYPE_5 | (newlen << SDS_TYPE_BITS);\n            }\n            break;\n        case SDS_TYPE_8:\n            SDS_HDR(8,s)->len += inc;\n            break;\n        case SDS_TYPE_16:\n            SDS_HDR(16,s)->len += inc;\n            break;\n        case SDS_TYPE_32:\n            SDS_HDR(32,s)->len += inc;\n            break;\n        case SDS_TYPE_64:\n            SDS_HDR(64,s)->len += inc;\n            break;\n    }\n}\n\n/* sdsalloc() = sdsavail() + sdslen() */\nstatic inline size_t sdsalloc(const sds s) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            return SDS_TYPE_5_LEN(flags);\n        case SDS_TYPE_8:\n            return SDS_HDR(8,s)->alloc;\n        case SDS_TYPE_16:\n            return SDS_HDR(16,s)->alloc;\n        case SDS_TYPE_32:\n            return SDS_HDR(32,s)->alloc;\n        case SDS_TYPE_64:\n            return SDS_HDR(64,s)->alloc;\n    }\n    return 0;\n}\n\nstatic inline void sdssetalloc(sds s, size_t newlen) {\n    unsigned char flags = s[-1];\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            /* Nothing to do, this type has no total allocation info. */\n            break;\n        case SDS_TYPE_8:\n            SDS_HDR(8,s)->alloc = newlen;\n            break;\n        case SDS_TYPE_16:\n            SDS_HDR(16,s)->alloc = newlen;\n            break;\n        case SDS_TYPE_32:\n            SDS_HDR(32,s)->alloc = newlen;\n            break;\n        case SDS_TYPE_64:\n            SDS_HDR(64,s)->alloc = newlen;\n            break;\n    }\n}\n\nsds sdsnewlen(const void *init, size_t initlen);\nsds sdsnew(const char *init);\nsds sdsempty(void);\nsds sdsdup(const sds s);\nvoid sdsfree(sds s);\nsds sdsgrowzero(sds s, size_t len);\nsds sdscatlen(sds s, const void *t, size_t len);\nsds sdscat(sds s, const char *t);\nsds sdscatsds(sds s, const sds t);\nsds sdscpylen(sds s, const char *t, size_t len);\nsds sdscpy(sds s, const char *t);\n\nsds sdscatvprintf(sds s, const char *fmt, va_list ap);\n#ifdef __GNUC__\nsds sdscatprintf(sds s, const char *fmt, ...)\n    __attribute__((format(printf, 2, 3)));\n#else\nsds sdscatprintf(sds s, const char *fmt, ...);\n#endif\n\nsds sdscatfmt(sds s, char const *fmt, ...);\nsds sdstrim(sds s, const char *cset);\nvoid sdsrange(sds s, ssize_t start, ssize_t end);\nvoid sdsupdatelen(sds s);\nvoid sdsclear(sds s);\nint sdscmp(const sds s1, const sds s2);\nsds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *count);\nvoid sdsfreesplitres(sds *tokens, int count);\nvoid sdstolower(sds s);\nvoid sdstoupper(sds s);\nsds sdsfromlonglong(long long value);\nsds sdscatrepr(sds s, const char *p, size_t len);\nsds *sdssplitargs(const char *line, int *argc);\nsds sdsmapchars(sds s, const char *from, const char *to, size_t setlen);\nsds sdsjoin(char **argv, int argc, char *sep);\nsds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen);\n\n/* Low level functions exposed to the user API */\nsds sdsMakeRoomFor(sds s, size_t addlen);\nvoid sdsIncrLen(sds s, ssize_t incr);\nsds sdsRemoveFreeSpace(sds s);\nsize_t sdsAllocSize(sds s);\nvoid *sdsAllocPtr(sds s);\n\n/* Export the allocator used by SDS to the program using SDS.\n * Sometimes the program SDS is linked to, may use a different set of\n * allocators, but may want to allocate or free things that SDS will\n * respectively free or allocate. */\nvoid *sds_malloc(size_t size);\nvoid *sds_realloc(void *ptr, size_t size);\nvoid sds_free(void *ptr);\n\n#ifdef REDIS_TEST\nint sdsTest(int argc, char *argv[]);\n#endif\n\n#endif\n";

const char *SRC_SDS_C = "/* SDSLib 2.0 -- A C dynamic strings library\n *\n * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>\n * Copyright (c) 2015, Oran Agra\n * Copyright (c) 2015, Redis Labs, Inc\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <assert.h>\n#include <limits.h>\n#include \"sds.h\"\n#include \"sdsalloc.h\"\n\nconst char *SDS_NOINIT = \"SDS_NOINIT\";\n\nstatic inline int sdsHdrSize(char type) {\n    switch(type&SDS_TYPE_MASK) {\n        case SDS_TYPE_5:\n            return sizeof(struct sdshdr5);\n        case SDS_TYPE_8:\n            return sizeof(struct sdshdr8);\n        case SDS_TYPE_16:\n            return sizeof(struct sdshdr16);\n        case SDS_TYPE_32:\n            return sizeof(struct sdshdr32);\n        case SDS_TYPE_64:\n            return sizeof(struct sdshdr64);\n    }\n    return 0;\n}\n\nstatic inline char sdsReqType(size_t string_size) {\n    if (string_size < 1<<5)\n        return SDS_TYPE_5;\n    if (string_size < 1<<8)\n        return SDS_TYPE_8;\n    if (string_size < 1<<16)\n        return SDS_TYPE_16;\n#if (LONG_MAX == LLONG_MAX)\n    if (string_size < 1ll<<32)\n        return SDS_TYPE_32;\n    return SDS_TYPE_64;\n#else\n    return SDS_TYPE_32;\n#endif\n}\n\n/* Create a new sds string with the content specified by the 'init' pointer\n * and 'initlen'.\n * If NULL is used for 'init' the string is initialized with zero bytes.\n * If SDS_NOINIT is used, the buffer is left uninitialized;\n *\n * The string is always null-terminated (all the sds strings are, always) so\n * even if you create an sds string with:\n *\n * mystring = sdsnewlen(\"abc\",3);\n *\n * You can print the string with printf() as there is an implicit \\0 at the\n * end of the string. However the string is binary safe and can contain\n * \\0 characters in the middle, as the length is stored in the sds header. */\nsds sdsnewlen(const void *init, size_t initlen) {\n    void *sh;\n    sds s;\n    char type = sdsReqType(initlen);\n    /* Empty strings are usually created in order to append. Use type 8\n     * since type 5 is not good at this. */\n    if (type == SDS_TYPE_5 && initlen == 0) type = SDS_TYPE_8;\n    int hdrlen = sdsHdrSize(type);\n    unsigned char *fp; /* flags pointer. */\n\n    sh = s_malloc(hdrlen+initlen+1);\n    if (sh == NULL) return NULL;\n    if (init==SDS_NOINIT)\n        init = NULL;\n    else if (!init)\n        memset(sh, 0, hdrlen+initlen+1);\n    s = (char*)sh+hdrlen;\n    fp = ((unsigned char*)s)-1;\n    switch(type) {\n        case SDS_TYPE_5: {\n            *fp = type | (initlen << SDS_TYPE_BITS);\n            break;\n        }\n        case SDS_TYPE_8: {\n            SDS_HDR_VAR(8,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            sh->len = initlen;\n            sh->alloc = initlen;\n            *fp = type;\n            break;\n        }\n    }\n    if (initlen && init)\n        memcpy(s, init, initlen);\n    s[initlen] = '\\0';\n    return s;\n}\n\n/* Create an empty (zero length) sds string. Even in this case the string\n * always has an implicit null term. */\nsds sdsempty(void) {\n    return sdsnewlen(\"\",0);\n}\n\n/* Create a new sds string starting from a null terminated C string. */\nsds sdsnew(const char *init) {\n    size_t initlen = (init == NULL) ? 0 : strlen(init);\n    return sdsnewlen(init, initlen);\n}\n\n/* Duplicate an sds string. */\nsds sdsdup(const sds s) {\n    return sdsnewlen(s, sdslen(s));\n}\n\n/* Free an sds string. No operation is performed if 's' is NULL. */\nvoid sdsfree(sds s) {\n    if (s == NULL) return;\n    s_free((char*)s-sdsHdrSize(s[-1]));\n}\n\n/* Set the sds string length to the length as obtained with strlen(), so\n * considering as content only up to the first null term character.\n *\n * This function is useful when the sds string is hacked manually in some\n * way, like in the following example:\n *\n * s = sdsnew(\"foobar\");\n * s[2] = '\\0';\n * sdsupdatelen(s);\n * printf(\"%d\\n\", sdslen(s));\n *\n * The output will be \"2\", but if we comment out the call to sdsupdatelen()\n * the output will be \"6\" as the string was modified but the logical length\n * remains 6 bytes. */\nvoid sdsupdatelen(sds s) {\n    size_t reallen = strlen(s);\n    sdssetlen(s, reallen);\n}\n\n/* Modify an sds string in-place to make it empty (zero length).\n * However all the existing buffer is not discarded but set as free space\n * so that next append operations will not require allocations up to the\n * number of bytes previously available. */\nvoid sdsclear(sds s) {\n    sdssetlen(s, 0);\n    s[0] = '\\0';\n}\n\n/* Enlarge the free space at the end of the sds string so that the caller\n * is sure that after calling this function can overwrite up to addlen\n * bytes after the end of the string, plus one more byte for nul term.\n *\n * Note: this does not change the *length* of the sds string as returned\n * by sdslen(), but only the free buffer space we have. */\nsds sdsMakeRoomFor(sds s, size_t addlen) {\n    void *sh, *newsh;\n    size_t avail = sdsavail(s);\n    size_t len, newlen, reqlen;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen;\n\n    /* Return ASAP if there is enough space left. */\n    if (avail >= addlen) return s;\n\n    len = sdslen(s);\n    sh = (char*)s-sdsHdrSize(oldtype);\n    reqlen = newlen = (len+addlen);\n    if (newlen < SDS_MAX_PREALLOC)\n        newlen *= 2;\n    else\n        newlen += SDS_MAX_PREALLOC;\n\n    type = sdsReqType(newlen);\n\n    /* Don't use type 5: the user is appending to the string and type 5 is\n     * not able to remember empty space, so sdsMakeRoomFor() must be called\n     * at every appending operation. */\n    if (type == SDS_TYPE_5) type = SDS_TYPE_8;\n\n    hdrlen = sdsHdrSize(type);\n    assert(hdrlen + newlen + 1 > reqlen); /* Catch size_t overflow */\n    if (oldtype==type) {\n        newsh = s_realloc(sh, hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+hdrlen;\n    } else {\n        /* Since the header size changes, need to move the string forward,\n         * and can't use realloc */\n        newsh = s_malloc(hdrlen+newlen+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, newlen);\n    return s;\n}\n\n/* Reallocate the sds string so that it has no free space at the end. The\n * contained string remains not altered, but next concatenation operations\n * will require a reallocation.\n *\n * After the call, the passed sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\nsds sdsRemoveFreeSpace(sds s) {\n    void *sh, *newsh;\n    char type, oldtype = s[-1] & SDS_TYPE_MASK;\n    int hdrlen, oldhdrlen = sdsHdrSize(oldtype);\n    size_t len = sdslen(s);\n    size_t avail = sdsavail(s);\n    sh = (char*)s-oldhdrlen;\n\n    /* Return ASAP if there is no space left. */\n    if (avail == 0) return s;\n\n    /* Check what would be the minimum SDS header that is just good enough to\n     * fit this string. */\n    type = sdsReqType(len);\n    hdrlen = sdsHdrSize(type);\n\n    /* If the type is the same, or at least a large enough type is still\n     * required, we just realloc(), letting the allocator to do the copy\n     * only if really needed. Otherwise if the change is huge, we manually\n     * reallocate the string to use the different header type. */\n    if (oldtype==type || type > SDS_TYPE_8) {\n        newsh = s_realloc(sh, oldhdrlen+len+1);\n        if (newsh == NULL) return NULL;\n        s = (char*)newsh+oldhdrlen;\n    } else {\n        newsh = s_malloc(hdrlen+len+1);\n        if (newsh == NULL) return NULL;\n        memcpy((char*)newsh+hdrlen, s, len+1);\n        s_free(sh);\n        s = (char*)newsh+hdrlen;\n        s[-1] = type;\n        sdssetlen(s, len);\n    }\n    sdssetalloc(s, len);\n    return s;\n}\n\n/* Return the total size of the allocation of the specified sds string,\n * including:\n * 1) The sds header before the pointer.\n * 2) The string.\n * 3) The free buffer at the end if any.\n * 4) The implicit null term.\n */\nsize_t sdsAllocSize(sds s) {\n    size_t alloc = sdsalloc(s);\n    return sdsHdrSize(s[-1])+alloc+1;\n}\n\n/* Return the pointer of the actual SDS allocation (normally SDS strings\n * are referenced by the start of the string buffer). */\nvoid *sdsAllocPtr(sds s) {\n    return (void*) (s-sdsHdrSize(s[-1]));\n}\n\n/* Increment the sds length and decrements the left free space at the\n * end of the string according to 'incr'. Also set the null term\n * in the new end of the string.\n *\n * This function is used in order to fix the string length after the\n * user calls sdsMakeRoomFor(), writes something after the end of\n * the current string, and finally needs to set the new length.\n *\n * Note: it is possible to use a negative increment in order to\n * right-trim the string.\n *\n * Usage example:\n *\n * Using sdsIncrLen() and sdsMakeRoomFor() it is possible to mount the\n * following schema, to cat bytes coming from the kernel to the end of an\n * sds string without copying into an intermediate buffer:\n *\n * oldlen = sdslen(s);\n * s = sdsMakeRoomFor(s, BUFFER_SIZE);\n * nread = read(fd, s+oldlen, BUFFER_SIZE);\n * ... check for nread <= 0 and handle it ...\n * sdsIncrLen(s, nread);\n */\nvoid sdsIncrLen(sds s, ssize_t incr) {\n    unsigned char flags = s[-1];\n    size_t len;\n    switch(flags&SDS_TYPE_MASK) {\n        case SDS_TYPE_5: {\n            unsigned char *fp = ((unsigned char*)s)-1;\n            unsigned char oldlen = SDS_TYPE_5_LEN(flags);\n            assert((incr > 0 && oldlen+incr < 32) || (incr < 0 && oldlen >= (unsigned int)(-incr)));\n            *fp = SDS_TYPE_5 | ((oldlen+incr) << SDS_TYPE_BITS);\n            len = oldlen+incr;\n            break;\n        }\n        case SDS_TYPE_8: {\n            SDS_HDR_VAR(8,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        case SDS_TYPE_16: {\n            SDS_HDR_VAR(16,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        case SDS_TYPE_32: {\n            SDS_HDR_VAR(32,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= (unsigned int)incr) || (incr < 0 && sh->len >= (unsigned int)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        case SDS_TYPE_64: {\n            SDS_HDR_VAR(64,s);\n            assert((incr >= 0 && sh->alloc-sh->len >= (uint64_t)incr) || (incr < 0 && sh->len >= (uint64_t)(-incr)));\n            len = (sh->len += incr);\n            break;\n        }\n        default: len = 0; /* Just to avoid compilation warnings. */\n    }\n    s[len] = '\\0';\n}\n\n/* Grow the sds to have the specified length. Bytes that were not part of\n * the original length of the sds will be set to zero.\n *\n * if the specified length is smaller than the current length, no operation\n * is performed. */\nsds sdsgrowzero(sds s, size_t len) {\n    size_t curlen = sdslen(s);\n\n    if (len <= curlen) return s;\n    s = sdsMakeRoomFor(s,len-curlen);\n    if (s == NULL) return NULL;\n\n    /* Make sure added region doesn't contain garbage */\n    memset(s+curlen,0,(len-curlen+1)); /* also set trailing \\0 byte */\n    sdssetlen(s, len);\n    return s;\n}\n\n/* Append the specified binary-safe string pointed by 't' of 'len' bytes to the\n * end of the specified sds string 's'.\n *\n * After the call, the passed sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\nsds sdscatlen(sds s, const void *t, size_t len) {\n    size_t curlen = sdslen(s);\n\n    s = sdsMakeRoomFor(s,len);\n    if (s == NULL) return NULL;\n    memcpy(s+curlen, t, len);\n    sdssetlen(s, curlen+len);\n    s[curlen+len] = '\\0';\n    return s;\n}\n\n/* Append the specified null termianted C string to the sds string 's'.\n *\n * After the call, the passed sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\nsds sdscat(sds s, const char *t) {\n    return sdscatlen(s, t, strlen(t));\n}\n\n/* Append the specified sds 't' to the existing sds 's'.\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\nsds sdscatsds(sds s, const sds t) {\n    return sdscatlen(s, t, sdslen(t));\n}\n\n/* Destructively modify the sds string 's' to hold the specified binary\n * safe string pointed by 't' of length 'len' bytes. */\nsds sdscpylen(sds s, const char *t, size_t len) {\n    if (sdsalloc(s) < len) {\n        s = sdsMakeRoomFor(s,len-sdslen(s));\n        if (s == NULL) return NULL;\n    }\n    memcpy(s, t, len);\n    s[len] = '\\0';\n    sdssetlen(s, len);\n    return s;\n}\n\n/* Like sdscpylen() but 't' must be a null-terminated string so that the length\n * of the string is obtained with strlen(). */\nsds sdscpy(sds s, const char *t) {\n    return sdscpylen(s, t, strlen(t));\n}\n\n/* Helper for sdscatlonglong() doing the actual number -> string\n * conversion. 's' must point to a string with room for at least\n * SDS_LLSTR_SIZE bytes.\n *\n * The function returns the length of the null-terminated string\n * representation stored at 's'. */\n#define SDS_LLSTR_SIZE 21\nint sdsll2str(char *s, long long value) {\n    char *p, aux;\n    unsigned long long v;\n    size_t l;\n\n    /* Generate the string representation, this method produces\n     * an reversed string. */\n    if (value < 0) {\n        /* Since v is unsigned, if value==LLONG_MIN then\n         * -LLONG_MIN will overflow. */\n        if (value != LLONG_MIN) {\n            v = -value;\n        } else {\n            v = ((unsigned long long)LLONG_MAX) + 1;\n        }\n    } else {\n        v = value;\n    }\n\n    p = s;\n    do {\n        *p++ = '0'+(v%10);\n        v /= 10;\n    } while(v);\n    if (value < 0) *p++ = '-';\n\n    /* Compute length and add null term. */\n    l = p-s;\n    *p = '\\0';\n\n    /* Reverse the string. */\n    p--;\n    while(s < p) {\n        aux = *s;\n        *s = *p;\n        *p = aux;\n        s++;\n        p--;\n    }\n    return l;\n}\n\n/* Identical sdsll2str(), but for unsigned long long type. */\nint sdsull2str(char *s, unsigned long long v) {\n    char *p, aux;\n    size_t l;\n\n    /* Generate the string representation, this method produces\n     * an reversed string. */\n    p = s;\n    do {\n        *p++ = '0'+(v%10);\n        v /= 10;\n    } while(v);\n\n    /* Compute length and add null term. */\n    l = p-s;\n    *p = '\\0';\n\n    /* Reverse the string. */\n    p--;\n    while(s < p) {\n        aux = *s;\n        *s = *p;\n        *p = aux;\n        s++;\n        p--;\n    }\n    return l;\n}\n\n/* Create an sds string from a long long value. It is much faster than:\n *\n * sdscatprintf(sdsempty(),\"%lld\\n\", value);\n */\nsds sdsfromlonglong(long long value) {\n    char buf[SDS_LLSTR_SIZE];\n    int len = sdsll2str(buf,value);\n\n    return sdsnewlen(buf,len);\n}\n\n/* Like sdscatprintf() but gets va_list instead of being variadic. */\nsds sdscatvprintf(sds s, const char *fmt, va_list ap) {\n    va_list cpy;\n    char staticbuf[1024], *buf = staticbuf, *t;\n    size_t buflen = strlen(fmt)*2;\n    int bufstrlen;\n\n    /* We try to start using a static buffer for speed.\n     * If not possible we revert to heap allocation. */\n    if (buflen > sizeof(staticbuf)) {\n        buf = s_malloc(buflen);\n        if (buf == NULL) return NULL;\n    } else {\n        buflen = sizeof(staticbuf);\n    }\n\n    /* Alloc enough space for buffer and \\0 after failing to\n     * fit the string in the current buffer size. */\n    while(1) {\n        va_copy(cpy,ap);\n        bufstrlen = vsnprintf(buf, buflen, fmt, cpy);\n        va_end(cpy);\n        if (bufstrlen < 0) {\n            if (buf != staticbuf) s_free(buf);\n            return NULL;\n        }\n        if (((size_t)bufstrlen) >= buflen) {\n            if (buf != staticbuf) s_free(buf);\n            buflen = ((size_t)bufstrlen) + 1;\n            buf = s_malloc(buflen);\n            if (buf == NULL) return NULL;\n            continue;\n        }\n        break;\n    }\n\n    /* Finally concat the obtained string to the SDS string and return it. */\n    t = sdscatlen(s, buf, bufstrlen);\n    if (buf != staticbuf) s_free(buf);\n    return t;\n}\n\n/* Append to the sds string 's' a string obtained using printf-alike format\n * specifier.\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call.\n *\n * Example:\n *\n * s = sdsnew(\"Sum is: \");\n * s = sdscatprintf(s,\"%d+%d = %d\",a,b,a+b).\n *\n * Often you need to create a string from scratch with the printf-alike\n * format. When this is the need, just use sdsempty() as the target string:\n *\n * s = sdscatprintf(sdsempty(), \"... your format ...\", args);\n */\nsds sdscatprintf(sds s, const char *fmt, ...) {\n    va_list ap;\n    char *t;\n    va_start(ap, fmt);\n    t = sdscatvprintf(s,fmt,ap);\n    va_end(ap);\n    return t;\n}\n\n/* This function is similar to sdscatprintf, but much faster as it does\n * not rely on sprintf() family functions implemented by the libc that\n * are often very slow. Moreover directly handling the sds string as\n * new data is concatenated provides a performance improvement.\n *\n * However this function only handles an incompatible subset of printf-alike\n * format specifiers:\n *\n * %s - C String\n * %S - SDS string\n * %i - signed int\n * %I - 64 bit signed integer (long long, int64_t)\n * %u - unsigned int\n * %U - 64 bit unsigned integer (unsigned long long, uint64_t)\n * %% - Verbatim \"%\" character.\n */\nsds sdscatfmt(sds s, char const *fmt, ...) {\n    size_t initlen = sdslen(s);\n    const char *f = fmt;\n    long i;\n    va_list ap;\n\n    /* To avoid continuous reallocations, let's start with a buffer that\n     * can hold at least two times the format string itself. It's not the\n     * best heuristic but seems to work in practice. */\n    s = sdsMakeRoomFor(s, initlen + strlen(fmt)*2);\n    va_start(ap,fmt);\n    f = fmt;    /* Next format specifier byte to process. */\n    i = initlen; /* Position of the next byte to write to dest str. */\n    while(*f) {\n        char next, *str;\n        size_t l;\n        long long num;\n        unsigned long long unum;\n\n        /* Make sure there is always space for at least 1 char. */\n        if (sdsavail(s)==0) {\n            s = sdsMakeRoomFor(s,1);\n        }\n\n        switch(*f) {\n        case '%':\n            next = *(f+1);\n            if (next == '\\0') break;\n            f++;\n            switch(next) {\n            case 's':\n            case 'S':\n                str = va_arg(ap,char*);\n                l = (next == 's') ? strlen(str) : sdslen(str);\n                if (sdsavail(s) < l) {\n                    s = sdsMakeRoomFor(s,l);\n                }\n                memcpy(s+i,str,l);\n                sdsinclen(s,l);\n                i += l;\n                break;\n            case 'i':\n            case 'I':\n                if (next == 'i')\n                    num = va_arg(ap,int);\n                else\n                    num = va_arg(ap,long long);\n                {\n                    char buf[SDS_LLSTR_SIZE];\n                    l = sdsll2str(buf,num);\n                    if (sdsavail(s) < l) {\n                        s = sdsMakeRoomFor(s,l);\n                    }\n                    memcpy(s+i,buf,l);\n                    sdsinclen(s,l);\n                    i += l;\n                }\n                break;\n            case 'u':\n            case 'U':\n                if (next == 'u')\n                    unum = va_arg(ap,unsigned int);\n                else\n                    unum = va_arg(ap,unsigned long long);\n                {\n                    char buf[SDS_LLSTR_SIZE];\n                    l = sdsull2str(buf,unum);\n                    if (sdsavail(s) < l) {\n                        s = sdsMakeRoomFor(s,l);\n                    }\n                    memcpy(s+i,buf,l);\n                    sdsinclen(s,l);\n                    i += l;\n                }\n                break;\n            default: /* Handle %% and generally %<unknown>. */\n                s[i++] = next;\n                sdsinclen(s,1);\n                break;\n            }\n            break;\n        default:\n            s[i++] = *f;\n            sdsinclen(s,1);\n            break;\n        }\n        f++;\n    }\n    va_end(ap);\n\n    /* Add null-term */\n    s[i] = '\\0';\n    return s;\n}\n\n/* Remove the part of the string from left and from right composed just of\n * contiguous characters found in 'cset', that is a null terminated C string.\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call.\n *\n * Example:\n *\n * s = sdsnew(\"AA...AA.a.aa.aHelloWorld     :::\");\n * s = sdstrim(s,\"Aa. :\");\n * printf(\"%s\\n\", s);\n *\n * Output will be just \"HelloWorld\".\n */\nsds sdstrim(sds s, const char *cset) {\n    char *end, *sp, *ep;\n    size_t len;\n\n    sp = s;\n    ep = end = s+sdslen(s)-1;\n    while(sp <= end && strchr(cset, *sp)) sp++;\n    while(ep > sp && strchr(cset, *ep)) ep--;\n    len = (ep-sp)+1;\n    if (s != sp) memmove(s, sp, len);\n    s[len] = '\\0';\n    sdssetlen(s,len);\n    return s;\n}\n\n/* Turn the string into a smaller (or equal) string containing only the\n * substring specified by the 'start' and 'end' indexes.\n *\n * start and end can be negative, where -1 means the last character of the\n * string, -2 the penultimate character, and so forth.\n *\n * The interval is inclusive, so the start and end characters will be part\n * of the resulting string.\n *\n * The string is modified in-place.\n *\n * Example:\n *\n * s = sdsnew(\"Hello World\");\n * sdsrange(s,1,-1); => \"ello World\"\n */\nvoid sdsrange(sds s, ssize_t start, ssize_t end) {\n    size_t newlen, len = sdslen(s);\n\n    if (len == 0) return;\n    if (start < 0) {\n        start = len+start;\n        if (start < 0) start = 0;\n    }\n    if (end < 0) {\n        end = len+end;\n        if (end < 0) end = 0;\n    }\n    newlen = (start > end) ? 0 : (end-start)+1;\n    if (newlen != 0) {\n        if (start >= (ssize_t)len) {\n            newlen = 0;\n        } else if (end >= (ssize_t)len) {\n            end = len-1;\n            newlen = (end-start)+1;\n        }\n    }\n    if (start && newlen) memmove(s, s+start, newlen);\n    s[newlen] = 0;\n    sdssetlen(s,newlen);\n}\n\n/* Apply tolower() to every character of the sds string 's'. */\nvoid sdstolower(sds s) {\n    size_t len = sdslen(s), j;\n\n    for (j = 0; j < len; j++) s[j] = tolower(s[j]);\n}\n\n/* Apply toupper() to every character of the sds string 's'. */\nvoid sdstoupper(sds s) {\n    size_t len = sdslen(s), j;\n\n    for (j = 0; j < len; j++) s[j] = toupper(s[j]);\n}\n\n/* Compare two sds strings s1 and s2 with memcmp().\n *\n * Return value:\n *\n *     positive if s1 > s2.\n *     negative if s1 < s2.\n *     0 if s1 and s2 are exactly the same binary string.\n *\n * If two strings share exactly the same prefix, but one of the two has\n * additional characters, the longer string is considered to be greater than\n * the smaller one. */\nint sdscmp(const sds s1, const sds s2) {\n    size_t l1, l2, minlen;\n    int cmp;\n\n    l1 = sdslen(s1);\n    l2 = sdslen(s2);\n    minlen = (l1 < l2) ? l1 : l2;\n    cmp = memcmp(s1,s2,minlen);\n    if (cmp == 0) return l1>l2? 1: (l1<l2? -1: 0);\n    return cmp;\n}\n\n/* Split 's' with separator in 'sep'. An array\n * of sds strings is returned. *count will be set\n * by reference to the number of tokens returned.\n *\n * On out of memory, zero length string, zero length\n * separator, NULL is returned.\n *\n * Note that 'sep' is able to split a string using\n * a multi-character separator. For example\n * sdssplit(\"foo_-_bar\",\"_-_\"); will return two\n * elements \"foo\" and \"bar\".\n *\n * This version of the function is binary-safe but\n * requires length arguments. sdssplit() is just the\n * same function but for zero-terminated strings.\n */\nsds *sdssplitlen(const char *s, ssize_t len, const char *sep, int seplen, int *count) {\n    int elements = 0, slots = 5;\n    long start = 0, j;\n    sds *tokens;\n\n    if (seplen < 1 || len <= 0) {\n        *count = 0;\n        return NULL;\n    }\n\n    tokens = s_malloc(sizeof(sds)*slots);\n    if (tokens == NULL) return NULL;\n\n    for (j = 0; j < (len-(seplen-1)); j++) {\n        /* make sure there is room for the next element and the final one */\n        if (slots < elements+2) {\n            sds *newtokens;\n\n            slots *= 2;\n            newtokens = s_realloc(tokens,sizeof(sds)*slots);\n            if (newtokens == NULL) goto cleanup;\n            tokens = newtokens;\n        }\n        /* search the separator */\n        if ((seplen == 1 && *(s+j) == sep[0]) || (memcmp(s+j,sep,seplen) == 0)) {\n            tokens[elements] = sdsnewlen(s+start,j-start);\n            if (tokens[elements] == NULL) goto cleanup;\n            elements++;\n            start = j+seplen;\n            j = j+seplen-1; /* skip the separator */\n        }\n    }\n    /* Add the final element. We are sure there is room in the tokens array. */\n    tokens[elements] = sdsnewlen(s+start,len-start);\n    if (tokens[elements] == NULL) goto cleanup;\n    elements++;\n    *count = elements;\n    return tokens;\n\ncleanup:\n    {\n        int i;\n        for (i = 0; i < elements; i++) sdsfree(tokens[i]);\n        s_free(tokens);\n        *count = 0;\n        return NULL;\n    }\n}\n\n/* Free the result returned by sdssplitlen(), or do nothing if 'tokens' is NULL. */\nvoid sdsfreesplitres(sds *tokens, int count) {\n    if (!tokens) return;\n    while(count--)\n        sdsfree(tokens[count]);\n    s_free(tokens);\n}\n\n/* Append to the sds string \"s\" an escaped string representation where\n * all the non-printable characters (tested with isprint()) are turned into\n * escapes in the form \"\\n\\r\\a....\" or \"\\x<hex-number>\".\n *\n * After the call, the modified sds string is no longer valid and all the\n * references must be substituted with the new pointer returned by the call. */\nsds sdscatrepr(sds s, const char *p, size_t len) {\n    s = sdscatlen(s,\"\\\"\",1);\n    while(len--) {\n        switch(*p) {\n        case '\\\\':\n        case '\"':\n            s = sdscatprintf(s,\"\\\\%c\",*p);\n            break;\n        case '\\n': s = sdscatlen(s,\"\\\\n\",2); break;\n        case '\\r': s = sdscatlen(s,\"\\\\r\",2); break;\n        case '\\t': s = sdscatlen(s,\"\\\\t\",2); break;\n        case '\\a': s = sdscatlen(s,\"\\\\a\",2); break;\n        case '\\b': s = sdscatlen(s,\"\\\\b\",2); break;\n        default:\n            if (isprint(*p))\n                s = sdscatprintf(s,\"%c\",*p);\n            else\n                s = sdscatprintf(s,\"\\\\x%02x\",(unsigned char)*p);\n            break;\n        }\n        p++;\n    }\n    return sdscatlen(s,\"\\\"\",1);\n}\n\n/* Helper function for sdssplitargs() that returns non zero if 'c'\n * is a valid hex digit. */\nint is_hex_digit(char c) {\n    return (c >= '0' && c <= '9') || (c >= 'a' && c <= 'f') ||\n           (c >= 'A' && c <= 'F');\n}\n\n/* Helper function for sdssplitargs() that converts a hex digit into an\n * integer from 0 to 15 */\nint hex_digit_to_int(char c) {\n    switch(c) {\n    case '0': return 0;\n    case '1': return 1;\n    case '2': return 2;\n    case '3': return 3;\n    case '4': return 4;\n    case '5': return 5;\n    case '6': return 6;\n    case '7': return 7;\n    case '8': return 8;\n    case '9': return 9;\n    case 'a': case 'A': return 10;\n    case 'b': case 'B': return 11;\n    case 'c': case 'C': return 12;\n    case 'd': case 'D': return 13;\n    case 'e': case 'E': return 14;\n    case 'f': case 'F': return 15;\n    default: return 0;\n    }\n}\n\n/* Split a line into arguments, where every argument can be in the\n * following programming-language REPL-alike form:\n *\n * foo bar \"newline are supported\\n\" and \"\\xff\\x00otherstuff\"\n *\n * The number of arguments is stored into *argc, and an array\n * of sds is returned.\n *\n * The caller should free the resulting array of sds strings with\n * sdsfreesplitres().\n *\n * Note that sdscatrepr() is able to convert back a string into\n * a quoted string in the same format sdssplitargs() is able to parse.\n *\n * The function returns the allocated tokens on success, even when the\n * input string is empty, or NULL if the input contains unbalanced\n * quotes or closed quotes followed by non space characters\n * as in: \"foo\"bar or \"foo'\n */\nsds *sdssplitargs(const char *line, int *argc) {\n    const char *p = line;\n    char *current = NULL;\n    char **vector = NULL;\n\n    *argc = 0;\n    while(1) {\n        /* skip blanks */\n        while(*p && isspace(*p)) p++;\n        if (*p) {\n            /* get a token */\n            int inq=0;  /* set to 1 if we are in \"quotes\" */\n            int insq=0; /* set to 1 if we are in 'single quotes' */\n            int done=0;\n\n            if (current == NULL) current = sdsempty();\n            while(!done) {\n                if (inq) {\n                    if (*p == '\\\\' && *(p+1) == 'x' &&\n                                             is_hex_digit(*(p+2)) &&\n                                             is_hex_digit(*(p+3)))\n                    {\n                        unsigned char byte;\n\n                        byte = (hex_digit_to_int(*(p+2))*16)+\n                                hex_digit_to_int(*(p+3));\n                        current = sdscatlen(current,(char*)&byte,1);\n                        p += 3;\n                    } else if (*p == '\\\\' && *(p+1)) {\n                        char c;\n\n                        p++;\n                        switch(*p) {\n                        case 'n': c = '\\n'; break;\n                        case 'r': c = '\\r'; break;\n                        case 't': c = '\\t'; break;\n                        case 'b': c = '\\b'; break;\n                        case 'a': c = '\\a'; break;\n                        default: c = *p; break;\n                        }\n                        current = sdscatlen(current,&c,1);\n                    } else if (*p == '\"') {\n                        /* closing quote must be followed by a space or\n                         * nothing at all. */\n                        if (*(p+1) && !isspace(*(p+1))) goto err;\n                        done=1;\n                    } else if (!*p) {\n                        /* unterminated quotes */\n                        goto err;\n                    } else {\n                        current = sdscatlen(current,p,1);\n                    }\n                } else if (insq) {\n                    if (*p == '\\\\' && *(p+1) == '\\'') {\n                        p++;\n                        current = sdscatlen(current,\"'\",1);\n                    } else if (*p == '\\'') {\n                        /* closing quote must be followed by a space or\n                         * nothing at all. */\n                        if (*(p+1) && !isspace(*(p+1))) goto err;\n                        done=1;\n                    } else if (!*p) {\n                        /* unterminated quotes */\n                        goto err;\n                    } else {\n                        current = sdscatlen(current,p,1);\n                    }\n                } else {\n                    switch(*p) {\n                    case ' ':\n                    case '\\n':\n                    case '\\r':\n                    case '\\t':\n                    case '\\0':\n                        done=1;\n                        break;\n                    case '\"':\n                        inq=1;\n                        break;\n                    case '\\'':\n                        insq=1;\n                        break;\n                    default:\n                        current = sdscatlen(current,p,1);\n                        break;\n                    }\n                }\n                if (*p) p++;\n            }\n            /* add the token to the vector */\n            vector = s_realloc(vector,((*argc)+1)*sizeof(char*));\n            vector[*argc] = current;\n            (*argc)++;\n            current = NULL;\n        } else {\n            /* Even on empty input string return something not NULL. */\n            if (vector == NULL) vector = s_malloc(sizeof(void*));\n            return vector;\n        }\n    }\n\nerr:\n    while((*argc)--)\n        sdsfree(vector[*argc]);\n    s_free(vector);\n    if (current) sdsfree(current);\n    *argc = 0;\n    return NULL;\n}\n\n/* Modify the string substituting all the occurrences of the set of\n * characters specified in the 'from' string to the corresponding character\n * in the 'to' array.\n *\n * For instance: sdsmapchars(mystring, \"ho\", \"01\", 2)\n * will have the effect of turning the string \"hello\" into \"0ell1\".\n *\n * The function returns the sds string pointer, that is always the same\n * as the input pointer since no resize is needed. */\nsds sdsmapchars(sds s, const char *from, const char *to, size_t setlen) {\n    size_t j, i, l = sdslen(s);\n\n    for (j = 0; j < l; j++) {\n        for (i = 0; i < setlen; i++) {\n            if (s[j] == from[i]) {\n                s[j] = to[i];\n                break;\n            }\n        }\n    }\n    return s;\n}\n\n/* Join an array of C strings using the specified separator (also a C string).\n * Returns the result as an sds string. */\nsds sdsjoin(char **argv, int argc, char *sep) {\n    sds join = sdsempty();\n    int j;\n\n    for (j = 0; j < argc; j++) {\n        join = sdscat(join, argv[j]);\n        if (j != argc-1) join = sdscat(join,sep);\n    }\n    return join;\n}\n\n/* Like sdsjoin, but joins an array of SDS strings. */\nsds sdsjoinsds(sds *argv, int argc, const char *sep, size_t seplen) {\n    sds join = sdsempty();\n    int j;\n\n    for (j = 0; j < argc; j++) {\n        join = sdscatsds(join, argv[j]);\n        if (j != argc-1) join = sdscatlen(join,sep,seplen);\n    }\n    return join;\n}\n\n/* Wrappers to the allocators used by SDS. Note that SDS will actually\n * just use the macros defined into sdsalloc.h in order to avoid to pay\n * the overhead of function calls. Here we define these wrappers only for\n * the programs SDS is linked to, if they want to touch the SDS internals\n * even if they use a different allocator. */\nvoid *sds_malloc(size_t size) { return s_malloc(size); }\nvoid *sds_realloc(void *ptr, size_t size) { return s_realloc(ptr,size); }\nvoid sds_free(void *ptr) { s_free(ptr); }\n\n#if defined(SDS_TEST_MAIN)\n#include <stdio.h>\n#include \"testhelp.h\"\n#include \"limits.h\"\n\n#define UNUSED(x) (void)(x)\nint sdsTest(void) {\n    {\n        sds x = sdsnew(\"foo\"), y;\n\n        test_cond(\"Create a string and obtain the length\",\n            sdslen(x) == 3 && memcmp(x,\"foo\\0\",4) == 0)\n\n        sdsfree(x);\n        x = sdsnewlen(\"foo\",2);\n        test_cond(\"Create a string with specified length\",\n            sdslen(x) == 2 && memcmp(x,\"fo\\0\",3) == 0)\n\n        x = sdscat(x,\"bar\");\n        test_cond(\"Strings concatenation\",\n            sdslen(x) == 5 && memcmp(x,\"fobar\\0\",6) == 0);\n\n        x = sdscpy(x,\"a\");\n        test_cond(\"sdscpy() against an originally longer string\",\n            sdslen(x) == 1 && memcmp(x,\"a\\0\",2) == 0)\n\n        x = sdscpy(x,\"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\");\n        test_cond(\"sdscpy() against an originally shorter string\",\n            sdslen(x) == 33 &&\n            memcmp(x,\"xyzxxxxxxxxxxyyyyyyyyyykkkkkkkkkk\\0\",33) == 0)\n\n        sdsfree(x);\n        x = sdscatprintf(sdsempty(),\"%d\",123);\n        test_cond(\"sdscatprintf() seems working in the base case\",\n            sdslen(x) == 3 && memcmp(x,\"123\\0\",4) == 0)\n\n        sdsfree(x);\n        x = sdscatprintf(sdsempty(),\"a%cb\",0);\n        test_cond(\"sdscatprintf() seems working with \\\\0 inside of result\",\n            sdslen(x) == 3 && memcmp(x,\"a\\0\"\"b\\0\",4) == 0)\n\n        {\n            sdsfree(x);\n            char etalon[1024*1024];\n            for (size_t i = 0; i < sizeof(etalon); i++) {\n                etalon[i] = '0';\n            }\n            x = sdscatprintf(sdsempty(),\"%0*d\",(int)sizeof(etalon),0);\n            test_cond(\"sdscatprintf() can print 1MB\",\n                sdslen(x) == sizeof(etalon) && memcmp(x,etalon,sizeof(etalon)) == 0)\n        }\n\n        sdsfree(x);\n        x = sdsnew(\"--\");\n        x = sdscatfmt(x, \"Hello %s World %I,%I--\", \"Hi!\", LLONG_MIN,LLONG_MAX);\n        test_cond(\"sdscatfmt() seems working in the base case\",\n            sdslen(x) == 60 &&\n            memcmp(x,\"--Hello Hi! World -9223372036854775808,\"\n                     \"9223372036854775807--\",60) == 0)\n        printf(\"[%s]\\n\",x);\n\n        sdsfree(x);\n        x = sdsnew(\"--\");\n        x = sdscatfmt(x, \"%u,%U--\", UINT_MAX, ULLONG_MAX);\n        test_cond(\"sdscatfmt() seems working with unsigned numbers\",\n            sdslen(x) == 35 &&\n            memcmp(x,\"--4294967295,18446744073709551615--\",35) == 0)\n\n        sdsfree(x);\n        x = sdsnew(\" x \");\n        sdstrim(x,\" x\");\n        test_cond(\"sdstrim() works when all chars match\",\n            sdslen(x) == 0)\n\n        sdsfree(x);\n        x = sdsnew(\" x \");\n        sdstrim(x,\" \");\n        test_cond(\"sdstrim() works when a single char remains\",\n            sdslen(x) == 1 && x[0] == 'x')\n\n        sdsfree(x);\n        x = sdsnew(\"xxciaoyyy\");\n        sdstrim(x,\"xy\");\n        test_cond(\"sdstrim() correctly trims characters\",\n            sdslen(x) == 4 && memcmp(x,\"ciao\\0\",5) == 0)\n\n        y = sdsdup(x);\n        sdsrange(y,1,1);\n        test_cond(\"sdsrange(...,1,1)\",\n            sdslen(y) == 1 && memcmp(y,\"i\\0\",2) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,1,-1);\n        test_cond(\"sdsrange(...,1,-1)\",\n            sdslen(y) == 3 && memcmp(y,\"iao\\0\",4) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,-2,-1);\n        test_cond(\"sdsrange(...,-2,-1)\",\n            sdslen(y) == 2 && memcmp(y,\"ao\\0\",3) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,2,1);\n        test_cond(\"sdsrange(...,2,1)\",\n            sdslen(y) == 0 && memcmp(y,\"\\0\",1) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,1,100);\n        test_cond(\"sdsrange(...,1,100)\",\n            sdslen(y) == 3 && memcmp(y,\"iao\\0\",4) == 0)\n\n        sdsfree(y);\n        y = sdsdup(x);\n        sdsrange(y,100,100);\n        test_cond(\"sdsrange(...,100,100)\",\n            sdslen(y) == 0 && memcmp(y,\"\\0\",1) == 0)\n\n        sdsfree(y);\n        sdsfree(x);\n        x = sdsnew(\"foo\");\n        y = sdsnew(\"foa\");\n        test_cond(\"sdscmp(foo,foa)\", sdscmp(x,y) > 0)\n\n        sdsfree(y);\n        sdsfree(x);\n        x = sdsnew(\"bar\");\n        y = sdsnew(\"bar\");\n        test_cond(\"sdscmp(bar,bar)\", sdscmp(x,y) == 0)\n\n        sdsfree(y);\n        sdsfree(x);\n        x = sdsnew(\"aar\");\n        y = sdsnew(\"bar\");\n        test_cond(\"sdscmp(bar,bar)\", sdscmp(x,y) < 0)\n\n        sdsfree(y);\n        sdsfree(x);\n        x = sdsnewlen(\"\\a\\n\\0foo\\r\",7);\n        y = sdscatrepr(sdsempty(),x,sdslen(x));\n        test_cond(\"sdscatrepr(...data...)\",\n            memcmp(y,\"\\\"\\\\a\\\\n\\\\x00foo\\\\r\\\"\",15) == 0)\n\n        {\n            char *p;\n            int step = 10, j, i;\n\n            sdsfree(x);\n            sdsfree(y);\n            x = sdsnew(\"0\");\n            test_cond(\"sdsnew() free/len buffers\", sdslen(x) == 1 && sdsavail(x) == 0);\n\n            /* Run the test a few times in order to hit the first two\n             * SDS header types. */\n            for (i = 0; i < 10; i++) {\n                int oldlen = sdslen(x);\n                x = sdsMakeRoomFor(x,step);\n                int type = x[-1]&SDS_TYPE_MASK;\n\n                test_cond(\"sdsMakeRoomFor() len\", sdslen(x) == oldlen);\n                if (type != SDS_TYPE_5) {\n                    test_cond(\"sdsMakeRoomFor() free\", sdsavail(x) >= step);\n                }\n                p = x+oldlen;\n                for (j = 0; j < step; j++) {\n                    p[j] = 'A'+j;\n                }\n                sdsIncrLen(x,step);\n            }\n            test_cond(\"sdsMakeRoomFor() content\",\n                memcmp(\"0ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ\",x,101) == 0);\n            test_cond(\"sdsMakeRoomFor() final length\",sdslen(x)==101);\n\n            sdsfree(x);\n        }\n    }\n    test_report()\n    return 0;\n}\n#endif\n\n#ifdef SDS_TEST_MAIN\nint main(void) {\n    return sdsTest();\n}\n#endif\n";

const char *SRC_STB_DS_H = "/* stb_ds.h - v0.67 - public domain data structures - Sean Barrett 2019\n\n   This is a single-header-file library that provides easy-to-use\n   dynamic arrays and hash tables for C (also works in C++).\n\n   For a gentle introduction:\n      http://nothings.org/stb_ds\n\n   To use this library, do this in *one* C or C++ file:\n      #define STB_DS_IMPLEMENTATION\n      #include \"stb_ds.h\"\n\nTABLE OF CONTENTS\n\n  Table of Contents\n  Compile-time options\n  License\n  Documentation\n  Notes\n  Notes - Dynamic arrays\n  Notes - Hash maps\n  Credits\n\nCOMPILE-TIME OPTIONS\n\n  #define STBDS_NO_SHORT_NAMES\n\n     This flag needs to be set globally.\n\n     By default stb_ds exposes shorter function names that are not qualified\n     with the \"stbds_\" prefix. If these names conflict with the names in your\n     code, define this flag.\n\n  #define STBDS_SIPHASH_2_4\n\n     This flag only needs to be set in the file containing #define STB_DS_IMPLEMENTATION.\n\n     By default stb_ds.h hashes using a weaker variant of SipHash and a custom hash for\n     4- and 8-byte keys. On 64-bit platforms, you can define the above flag to force\n     stb_ds.h to use specification-compliant SipHash-2-4 for all keys. Doing so makes\n     hash table insertion about 20% slower on 4- and 8-byte keys, 5% slower on\n     64-byte keys, and 10% slower on 256-byte keys on my test computer.\n\n  #define STBDS_REALLOC(context,ptr,size) better_realloc\n  #define STBDS_FREE(context,ptr)         better_free\n\n     These defines only need to be set in the file containing #define STB_DS_IMPLEMENTATION.\n\n     By default stb_ds uses stdlib realloc() and free() for memory management. You can\n     substitute your own functions instead by defining these symbols. You must either\n     define both, or neither. Note that at the moment, 'context' will always be NULL.\n     @TODO add an array/hash initialization function that takes a memory context pointer.\n\n  #define STBDS_UNIT_TESTS\n\n     Defines a function stbds_unit_tests() that checks the functioning of the data structures.\n\n  Note that on older versions of gcc (e.g. 5.x.x) you may need to build with '-std=c++0x'\n     (or equivalentally '-std=c++11') when using anonymous structures as seen on the web\n     page or in STBDS_UNIT_TESTS.\n\nLICENSE\n\n  Placed in the public domain and also MIT licensed.\n  See end of file for detailed license information.\n\nDOCUMENTATION\n\n  Dynamic Arrays\n\n    Non-function interface:\n\n      Declare an empty dynamic array of type T\n        T* foo = NULL;\n\n      Access the i'th item of a dynamic array 'foo' of type T, T* foo:\n        foo[i]\n\n    Functions (actually macros)\n\n      arrfree:\n        void arrfree(T*);\n          Frees the array.\n\n      arrlen:\n        ptrdiff_t arrlen(T*);\n          Returns the number of elements in the array.\n\n      arrlenu:\n        size_t arrlenu(T*);\n          Returns the number of elements in the array as an unsigned type.\n\n      arrpop:\n        T arrpop(T* a)\n          Removes the final element of the array and returns it.\n\n      arrput:\n        T arrput(T* a, T b);\n          Appends the item b to the end of array a. Returns b.\n\n      arrins:\n        T arrins(T* a, int p, T b);\n          Inserts the item b into the middle of array a, into a[p],\n          moving the rest of the array over. Returns b.\n\n      arrinsn:\n        void arrinsn(T* a, int p, int n);\n          Inserts n uninitialized items into array a starting at a[p],\n          moving the rest of the array over.\n\n      arraddnptr:\n        T* arraddnptr(T* a, int n)\n          Appends n uninitialized items onto array at the end.\n          Returns a pointer to the first uninitialized item added.\n\n      arraddnindex:\n        size_t arraddnindex(T* a, int n)\n          Appends n uninitialized items onto array at the end.\n          Returns the index of the first uninitialized item added.\n\n      arrdel:\n        void arrdel(T* a, int p);\n          Deletes the element at a[p], moving the rest of the array over.\n\n      arrdeln:\n        void arrdeln(T* a, int p, int n);\n          Deletes n elements starting at a[p], moving the rest of the array over.\n\n      arrdelswap:\n        void arrdelswap(T* a, int p);\n          Deletes the element at a[p], replacing it with the element from\n          the end of the array. O(1) performance.\n\n      arrsetlen:\n        void arrsetlen(T* a, int n);\n          Changes the length of the array to n. Allocates uninitialized\n          slots at the end if necessary.\n\n      arrsetcap:\n        size_t arrsetcap(T* a, int n);\n          Sets the length of allocated storage to at least n. It will not\n          change the length of the array.\n\n      arrcap:\n        size_t arrcap(T* a);\n          Returns the number of total elements the array can contain without\n          needing to be reallocated.\n\n  Hash maps & String hash maps\n\n    Given T is a structure type: struct { TK key; TV value; }. Note that some\n    functions do not require TV value and can have other fields. For string\n    hash maps, TK must be 'char *'.\n\n    Special interface:\n\n      stbds_rand_seed:\n        void stbds_rand_seed(size_t seed);\n          For security against adversarially chosen data, you should seed the\n          library with a strong random number. Or at least seed it with time().\n\n      stbds_hash_string:\n        size_t stbds_hash_string(char *str, size_t seed);\n          Returns a hash value for a string.\n\n      stbds_hash_bytes:\n        size_t stbds_hash_bytes(void *p, size_t len, size_t seed);\n          These functions hash an arbitrary number of bytes. The function\n          uses a custom hash for 4- and 8-byte data, and a weakened version\n          of SipHash for everything else. On 64-bit platforms you can get\n          specification-compliant SipHash-2-4 on all data by defining\n          STBDS_SIPHASH_2_4, at a significant cost in speed.\n\n    Non-function interface:\n\n      Declare an empty hash map of type T\n        T* foo = NULL;\n\n      Access the i'th entry in a hash table T* foo:\n        foo[i]\n\n    Function interface (actually macros):\n\n      hmfree\n      shfree\n        void hmfree(T*);\n        void shfree(T*);\n          Frees the hashmap and sets the pointer to NULL.\n\n      hmlen\n      shlen\n        ptrdiff_t hmlen(T*)\n        ptrdiff_t shlen(T*)\n          Returns the number of elements in the hashmap.\n\n      hmlenu\n      shlenu\n        size_t hmlenu(T*)\n        size_t shlenu(T*)\n          Returns the number of elements in the hashmap.\n\n      hmgeti\n      shgeti\n      hmgeti_ts\n        ptrdiff_t hmgeti(T*, TK key)\n        ptrdiff_t shgeti(T*, char* key)\n        ptrdiff_t hmgeti_ts(T*, TK key, ptrdiff_t tempvar)\n          Returns the index in the hashmap which has the key 'key', or -1\n          if the key is not present.\n\n      hmget\n      hmget_ts\n      shget\n        TV hmget(T*, TK key)\n        TV shget(T*, char* key)\n        TV hmget_ts(T*, TK key, ptrdiff_t tempvar)\n          Returns the value corresponding to 'key' in the hashmap.\n          The structure must have a 'value' field\n\n      hmgets\n      shgets\n        T hmgets(T*, TK key)\n        T shgets(T*, char* key)\n          Returns the structure corresponding to 'key' in the hashmap.\n\n      hmgetp\n      shgetp\n      hmgetp_ts\n      hmgetp_null\n      shgetp_null\n        T* hmgetp(T*, TK key)\n        T* shgetp(T*, char* key)\n        T* hmgetp_ts(T*, TK key, ptrdiff_t tempvar)\n        T* hmgetp_null(T*, TK key)\n        T* shgetp_null(T*, char *key)\n          Returns a pointer to the structure corresponding to 'key' in\n          the hashmap. Functions ending in \"_null\" return NULL if the key\n          is not present in the hashmap; the others return a pointer to a\n          structure holding the default value (but not the searched-for key).\n\n      hmdefault\n      shdefault\n        TV hmdefault(T*, TV value)\n        TV shdefault(T*, TV value)\n          Sets the default value for the hashmap, the value which will be\n          returned by hmget/shget if the key is not present.\n\n      hmdefaults\n      shdefaults\n        TV hmdefaults(T*, T item)\n        TV shdefaults(T*, T item)\n          Sets the default struct for the hashmap, the contents which will be\n          returned by hmgets/shgets if the key is not present.\n\n      hmput\n      shput\n        TV hmput(T*, TK key, TV value)\n        TV shput(T*, char* key, TV value)\n          Inserts a <key,value> pair into the hashmap. If the key is already\n          present in the hashmap, updates its value.\n\n      hmputs\n      shputs\n        T hmputs(T*, T item)\n        T shputs(T*, T item)\n          Inserts a struct with T.key into the hashmap. If the struct is already\n          present in the hashmap, updates it.\n\n      hmdel\n      shdel\n        int hmdel(T*, TK key)\n        int shdel(T*, char* key)\n          If 'key' is in the hashmap, deletes its entry and returns 1.\n          Otherwise returns 0.\n\n    Function interface (actually macros) for strings only:\n\n      sh_new_strdup\n        void sh_new_strdup(T*);\n          Overwrites the existing pointer with a newly allocated\n          string hashmap which will automatically allocate and free\n          each string key using realloc/free\n\n      sh_new_arena\n        void sh_new_arena(T*);\n          Overwrites the existing pointer with a newly allocated\n          string hashmap which will automatically allocate each string\n          key to a string arena. Every string key ever used by this\n          hash table remains in the arena until the arena is freed.\n          Additionally, any key which is deleted and reinserted will\n          be allocated multiple times in the string arena.\n\nNOTES\n\n  * These data structures are realloc'd when they grow, and the macro\n    \"functions\" write to the provided pointer. This means: (a) the pointer\n    must be an lvalue, and (b) the pointer to the data structure is not\n    stable, and you must maintain it the same as you would a realloc'd\n    pointer. For example, if you pass a pointer to a dynamic array to a\n    function which updates it, the function must return back the new\n    pointer to the caller. This is the price of trying to do this in C.\n\n  * The following are the only functions that are thread-safe on a single data\n    structure, i.e. can be run in multiple threads simultaneously on the same\n    data structure\n        hmlen        shlen\n        hmlenu       shlenu\n        hmget_ts     shget_ts\n        hmgeti_ts    shgeti_ts\n        hmgets_ts    shgets_ts\n\n  * You iterate over the contents of a dynamic array and a hashmap in exactly\n    the same way, using arrlen/hmlen/shlen:\n\n      for (i=0; i < arrlen(foo); ++i)\n         ... foo[i] ...\n\n  * All operations except arrins/arrdel are O(1) amortized, but individual\n    operations can be slow, so these data structures may not be suitable\n    for real time use. Dynamic arrays double in capacity as needed, so\n    elements are copied an average of once. Hash tables double/halve\n    their size as needed, with appropriate hysteresis to maintain O(1)\n    performance.\n\nNOTES - DYNAMIC ARRAY\n\n  * If you know how long a dynamic array is going to be in advance, you can avoid\n    extra memory allocations by using arrsetlen to allocate it to that length in\n    advance and use foo[n] while filling it out, or arrsetcap to allocate the memory\n    for that length and use arrput/arrpush as normal.\n\n  * Unlike some other versions of the dynamic array, this version should\n    be safe to use with strict-aliasing optimizations.\n\nNOTES - HASH MAP\n\n  * For compilers other than GCC and clang (e.g. Visual Studio), for hmput/hmget/hmdel\n    and variants, the key must be an lvalue (so the macro can take the address of it).\n    Extensions are used that eliminate this requirement if you're using C99 and later\n    in GCC or clang, or if you're using C++ in GCC. But note that this can make your\n    code less portable.\n\n  * To test for presence of a key in a hashmap, just do 'hmgeti(foo,key) >= 0'.\n\n  * The iteration order of your data in the hashmap is determined solely by the\n    order of insertions and deletions. In particular, if you never delete, new\n    keys are always added at the end of the array. This will be consistent\n    across all platforms and versions of the library. However, you should not\n    attempt to serialize the internal hash table, as the hash is not consistent\n    between different platforms, and may change with future versions of the library.\n\n  * Use sh_new_arena() for string hashmaps that you never delete from. Initialize\n    with NULL if you're managing the memory for your strings, or your strings are\n    never freed (at least until the hashmap is freed). Otherwise, use sh_new_strdup().\n    @TODO: make an arena variant that garbage collects the strings with a trivial\n    copy collector into a new arena whenever the table shrinks / rebuilds. Since\n    current arena recommendation is to only use arena if it never deletes, then\n    this can just replace current arena implementation.\n\n  * If adversarial input is a serious concern and you're on a 64-bit platform,\n    enable STBDS_SIPHASH_2_4 (see the 'Compile-time options' section), and pass\n    a strong random number to stbds_rand_seed.\n\n  * The default value for the hash table is stored in foo[-1], so if you\n    use code like 'hmget(T,k)->value = 5' you can accidentally overwrite\n    the value stored by hmdefault if 'k' is not present.\n\nCREDITS\n\n  Sean Barrett -- library, idea for dynamic array API/implementation\n  Per Vognsen  -- idea for hash table API/implementation\n  Rafael Sachetto -- arrpop()\n  github:HeroicKatora -- arraddn() reworking\n\n  Bugfixes:\n    Andy Durdin\n    Shane Liesegang\n    Vinh Truong\n    Andreas Molzer\n    github:hashitaku\n    github:srdjanstipic\n    Macoy Madson\n    Andreas Vennstrom\n    Tobias Mansfield-Williams\n*/\n\n#ifdef STBDS_UNIT_TESTS\n#define _CRT_SECURE_NO_WARNINGS\n#endif\n\n#ifndef INCLUDE_STB_DS_H\n#define INCLUDE_STB_DS_H\n\n#include <stddef.h>\n#include <string.h>\n\n#ifndef STBDS_NO_SHORT_NAMES\n#define arrlen      stbds_arrlen\n#define arrlenu     stbds_arrlenu\n#define arrput      stbds_arrput\n#define arrpush     stbds_arrput\n#define arrpop      stbds_arrpop\n#define arrfree     stbds_arrfree\n#define arraddn     stbds_arraddn // deprecated, use one of the following instead:\n#define arraddnptr  stbds_arraddnptr\n#define arraddnindex stbds_arraddnindex\n#define arrsetlen   stbds_arrsetlen\n#define arrlast     stbds_arrlast\n#define arrins      stbds_arrins\n#define arrinsn     stbds_arrinsn\n#define arrdel      stbds_arrdel\n#define arrdeln     stbds_arrdeln\n#define arrdelswap  stbds_arrdelswap\n#define arrcap      stbds_arrcap\n#define arrsetcap   stbds_arrsetcap\n\n#define hmput       stbds_hmput\n#define hmputs      stbds_hmputs\n#define hmget       stbds_hmget\n#define hmget_ts    stbds_hmget_ts\n#define hmgets      stbds_hmgets\n#define hmgetp      stbds_hmgetp\n#define hmgetp_ts   stbds_hmgetp_ts\n#define hmgetp_null stbds_hmgetp_null\n#define hmgeti      stbds_hmgeti\n#define hmgeti_ts   stbds_hmgeti_ts\n#define hmdel       stbds_hmdel\n#define hmlen       stbds_hmlen\n#define hmlenu      stbds_hmlenu\n#define hmfree      stbds_hmfree\n#define hmdefault   stbds_hmdefault\n#define hmdefaults  stbds_hmdefaults\n\n#define shput       stbds_shput\n#define shputi      stbds_shputi\n#define shputs      stbds_shputs\n#define shget       stbds_shget\n#define shgeti      stbds_shgeti\n#define shgets      stbds_shgets\n#define shgetp      stbds_shgetp\n#define shgetp_null stbds_shgetp_null\n#define shdel       stbds_shdel\n#define shlen       stbds_shlen\n#define shlenu      stbds_shlenu\n#define shfree      stbds_shfree\n#define shdefault   stbds_shdefault\n#define shdefaults  stbds_shdefaults\n#define sh_new_arena  stbds_sh_new_arena\n#define sh_new_strdup stbds_sh_new_strdup\n\n#define stralloc    stbds_stralloc\n#define strreset    stbds_strreset\n#endif\n\n#if defined(STBDS_REALLOC) && !defined(STBDS_FREE) || !defined(STBDS_REALLOC) && defined(STBDS_FREE)\n#error \"You must define both STBDS_REALLOC and STBDS_FREE, or neither.\"\n#endif\n#if !defined(STBDS_REALLOC) && !defined(STBDS_FREE)\n#include <stdlib.h>\n#define STBDS_REALLOC(c,p,s) realloc(p,s)\n#define STBDS_FREE(c,p)      free(p)\n#endif\n\n#ifdef _MSC_VER\n#define STBDS_NOTUSED(v)  (void)(v)\n#else\n#define STBDS_NOTUSED(v)  (void)sizeof(v)\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// for security against attackers, seed the library with a random number, at least time() but stronger is better\nextern void stbds_rand_seed(size_t seed);\n\n// these are the hash functions used internally if you want to test them or use them for other purposes\nextern size_t stbds_hash_bytes(void *p, size_t len, size_t seed);\nextern size_t stbds_hash_string(char *str, size_t seed);\n\n// this is a simple string arena allocator, initialize with e.g. 'stbds_string_arena my_arena={0}'.\ntypedef struct stbds_string_arena stbds_string_arena;\nextern char * stbds_stralloc(stbds_string_arena *a, char *str);\nextern void   stbds_strreset(stbds_string_arena *a);\n\n// have to #define STBDS_UNIT_TESTS to call this\nextern void stbds_unit_tests(void);\n\n///////////////\n//\n// Everything below here is implementation details\n//\n\nextern void * stbds_arrgrowf(void *a, size_t elemsize, size_t addlen, size_t min_cap);\nextern void   stbds_arrfreef(void *a);\nextern void   stbds_hmfree_func(void *p, size_t elemsize);\nextern void * stbds_hmget_key(void *a, size_t elemsize, void *key, size_t keysize, int mode);\nextern void * stbds_hmget_key_ts(void *a, size_t elemsize, void *key, size_t keysize, ptrdiff_t *temp, int mode);\nextern void * stbds_hmput_default(void *a, size_t elemsize);\nextern void * stbds_hmput_key(void *a, size_t elemsize, void *key, size_t keysize, int mode);\nextern void * stbds_hmdel_key(void *a, size_t elemsize, void *key, size_t keysize, size_t keyoffset, int mode);\nextern void * stbds_shmode_func(size_t elemsize, int mode);\n\n#ifdef __cplusplus\n}\n#endif\n\n#if defined(__GNUC__) || defined(__clang__)\n#define STBDS_HAS_TYPEOF\n#ifdef __cplusplus\n//#define STBDS_HAS_LITERAL_ARRAY  // this is currently broken for clang\n#endif\n#endif\n\n#if !defined(__cplusplus)\n#if defined(__STDC_VERSION__) && __STDC_VERSION__ >= 199901L\n#define STBDS_HAS_LITERAL_ARRAY\n#endif\n#endif\n\n// this macro takes the address of the argument, but on gcc/clang can accept rvalues\n#if defined(STBDS_HAS_LITERAL_ARRAY) && defined(STBDS_HAS_TYPEOF)\n  #if __clang__\n  #define STBDS_ADDRESSOF(typevar, value)     ((__typeof__(typevar)[1]){value}) // literal array decays to pointer to value\n  #else\n  #define STBDS_ADDRESSOF(typevar, value)     ((typeof(typevar)[1]){value}) // literal array decays to pointer to value\n  #endif\n#else\n#define STBDS_ADDRESSOF(typevar, value)     &(value)\n#endif\n\n#define STBDS_OFFSETOF(var,field)           ((char *) &(var)->field - (char *) (var))\n\n#define stbds_header(t)  ((stbds_array_header *) (t) - 1)\n#define stbds_temp(t)    stbds_header(t)->temp\n#define stbds_temp_key(t) (*(char **) stbds_header(t)->hash_table)\n\n#define stbds_arrsetcap(a,n)   (stbds_arrgrow(a,0,n))\n#define stbds_arrsetlen(a,n)   ((stbds_arrcap(a) < (size_t) (n) ? stbds_arrsetcap((a),(size_t)(n)),0 : 0), (a) ? stbds_header(a)->length = (size_t) (n) : 0)\n#define stbds_arrcap(a)        ((a) ? stbds_header(a)->capacity : 0)\n#define stbds_arrlen(a)        ((a) ? (ptrdiff_t) stbds_header(a)->length : 0)\n#define stbds_arrlenu(a)       ((a) ?             stbds_header(a)->length : 0)\n#define stbds_arrput(a,v)      (stbds_arrmaybegrow(a,1), (a)[stbds_header(a)->length++] = (v))\n#define stbds_arrpush          stbds_arrput  // synonym\n#define stbds_arrpop(a)        (stbds_header(a)->length--, (a)[stbds_header(a)->length])\n#define stbds_arraddn(a,n)     ((void)(stbds_arraddnindex(a, n)))    // deprecated, use one of the following instead:\n#define stbds_arraddnptr(a,n)  (stbds_arrmaybegrow(a,n), (n) ? (stbds_header(a)->length += (n), &(a)[stbds_header(a)->length-(n)]) : (a))\n#define stbds_arraddnindex(a,n)(stbds_arrmaybegrow(a,n), (n) ? (stbds_header(a)->length += (n), stbds_header(a)->length-(n)) : stbds_arrlen(a))\n#define stbds_arraddnoff       stbds_arraddnindex\n#define stbds_arrlast(a)       ((a)[stbds_header(a)->length-1])\n#define stbds_arrfree(a)       ((void) ((a) ? STBDS_FREE(NULL,stbds_header(a)) : (void)0), (a)=NULL)\n#define stbds_arrdel(a,i)      stbds_arrdeln(a,i,1)\n#define stbds_arrdeln(a,i,n)   (memmove(&(a)[i], &(a)[(i)+(n)], sizeof *(a) * (stbds_header(a)->length-(n)-(i))), stbds_header(a)->length -= (n))\n#define stbds_arrdelswap(a,i)  ((a)[i] = stbds_arrlast(a), stbds_header(a)->length -= 1)\n#define stbds_arrinsn(a,i,n)   (stbds_arraddn((a),(n)), memmove(&(a)[(i)+(n)], &(a)[i], sizeof *(a) * (stbds_header(a)->length-(n)-(i))))\n#define stbds_arrins(a,i,v)    (stbds_arrinsn((a),(i),1), (a)[i]=(v))\n\n#define stbds_arrmaybegrow(a,n)  ((!(a) || stbds_header(a)->length + (n) > stbds_header(a)->capacity) \\\n                                  ? (stbds_arrgrow(a,n,0),0) : 0)\n\n#define stbds_arrgrow(a,b,c)   ((a) = stbds_arrgrowf_wrapper((a), sizeof *(a), (b), (c)))\n\n#define stbds_hmput(t, k, v) \\\n    ((t) = stbds_hmput_key_wrapper((t), sizeof *(t), (void*) STBDS_ADDRESSOF((t)->key, (k)), sizeof (t)->key, 0),   \\\n     (t)[stbds_temp((t)-1)].key = (k),    \\\n     (t)[stbds_temp((t)-1)].value = (v))\n\n#define stbds_hmputs(t, s) \\\n    ((t) = stbds_hmput_key_wrapper((t), sizeof *(t), &(s).key, sizeof (s).key, STBDS_HM_BINARY), \\\n     (t)[stbds_temp((t)-1)] = (s))\n\n#define stbds_hmgeti(t,k) \\\n    ((t) = stbds_hmget_key_wrapper((t), sizeof *(t), (void*) STBDS_ADDRESSOF((t)->key, (k)), sizeof (t)->key, STBDS_HM_BINARY), \\\n      stbds_temp((t)-1))\n\n#define stbds_hmgeti_ts(t,k,temp) \\\n    ((t) = stbds_hmget_key_ts_wrapper((t), sizeof *(t), (void*) STBDS_ADDRESSOF((t)->key, (k)), sizeof (t)->key, &(temp), STBDS_HM_BINARY), \\\n      (temp))\n\n#define stbds_hmgetp(t, k) \\\n    ((void) stbds_hmgeti(t,k), &(t)[stbds_temp((t)-1)])\n\n#define stbds_hmgetp_ts(t, k, temp) \\\n    ((void) stbds_hmgeti_ts(t,k,temp), &(t)[temp])\n\n#define stbds_hmdel(t,k) \\\n    (((t) = stbds_hmdel_key_wrapper((t),sizeof *(t), (void*) STBDS_ADDRESSOF((t)->key, (k)), sizeof (t)->key, STBDS_OFFSETOF((t),key), STBDS_HM_BINARY)),(t)?stbds_temp((t)-1):0)\n\n#define stbds_hmdefault(t, v) \\\n    ((t) = stbds_hmput_default_wrapper((t), sizeof *(t)), (t)[-1].value = (v))\n\n#define stbds_hmdefaults(t, s) \\\n    ((t) = stbds_hmput_default_wrapper((t), sizeof *(t)), (t)[-1] = (s))\n\n#define stbds_hmfree(p)        \\\n    ((void) ((p) != NULL ? stbds_hmfree_func((p)-1,sizeof*(p)),0 : 0),(p)=NULL)\n\n#define stbds_hmgets(t, k)    (*stbds_hmgetp(t,k))\n#define stbds_hmget(t, k)     (stbds_hmgetp(t,k)->value)\n#define stbds_hmget_ts(t, k, temp)  (stbds_hmgetp_ts(t,k,temp)->value)\n#define stbds_hmlen(t)        ((t) ? (ptrdiff_t) stbds_header((t)-1)->length-1 : 0)\n#define stbds_hmlenu(t)       ((t) ?             stbds_header((t)-1)->length-1 : 0)\n#define stbds_hmgetp_null(t,k)  (stbds_hmgeti(t,k) == -1 ? NULL : &(t)[stbds_temp((t)-1)])\n\n#define stbds_shput(t, k, v) \\\n    ((t) = stbds_hmput_key_wrapper((t), sizeof *(t), (void*) (k), sizeof (t)->key, STBDS_HM_STRING),   \\\n     (t)[stbds_temp((t)-1)].value = (v))\n\n#define stbds_shputi(t, k, v) \\\n    ((t) = stbds_hmput_key_wrapper((t), sizeof *(t), (void*) (k), sizeof (t)->key, STBDS_HM_STRING),   \\\n     (t)[stbds_temp((t)-1)].value = (v), stbds_temp((t)-1))\n\n#define stbds_shputs(t, s) \\\n    ((t) = stbds_hmput_key_wrapper((t), sizeof *(t), (void*) (s).key, sizeof (s).key, STBDS_HM_STRING), \\\n     (t)[stbds_temp((t)-1)] = (s), \\\n     (t)[stbds_temp((t)-1)].key = stbds_temp_key((t)-1)) // above line overwrites whole structure, so must rewrite key here if it was allocated internally\n\n#define stbds_pshput(t, p) \\\n    ((t) = stbds_hmput_key_wrapper((t), sizeof *(t), (void*) (p)->key, sizeof (p)->key, STBDS_HM_PTR_TO_STRING), \\\n     (t)[stbds_temp((t)-1)] = (p))\n\n#define stbds_shgeti(t,k) \\\n     ((t) = stbds_hmget_key_wrapper((t), sizeof *(t), (void*) (k), sizeof (t)->key, STBDS_HM_STRING), \\\n      stbds_temp((t)-1))\n\n#define stbds_pshgeti(t,k) \\\n     ((t) = stbds_hmget_key_wrapper((t), sizeof *(t), (void*) (k), sizeof (*(t))->key, STBDS_HM_PTR_TO_STRING), \\\n      stbds_temp((t)-1))\n\n#define stbds_shgetp(t, k) \\\n    ((void) stbds_shgeti(t,k), &(t)[stbds_temp((t)-1)])\n\n#define stbds_pshget(t, k) \\\n    ((void) stbds_pshgeti(t,k), (t)[stbds_temp((t)-1)])\n\n#define stbds_shdel(t,k) \\\n    (((t) = stbds_hmdel_key_wrapper((t),sizeof *(t), (void*) (k), sizeof (t)->key, STBDS_OFFSETOF((t),key), STBDS_HM_STRING)),(t)?stbds_temp((t)-1):0)\n#define stbds_pshdel(t,k) \\\n    (((t) = stbds_hmdel_key_wrapper((t),sizeof *(t), (void*) (k), sizeof (*(t))->key, STBDS_OFFSETOF(*(t),key), STBDS_HM_PTR_TO_STRING)),(t)?stbds_temp((t)-1):0)\n\n#define stbds_sh_new_arena(t)  \\\n    ((t) = stbds_shmode_func_wrapper(t, sizeof *(t), STBDS_SH_ARENA))\n#define stbds_sh_new_strdup(t) \\\n    ((t) = stbds_shmode_func_wrapper(t, sizeof *(t), STBDS_SH_STRDUP))\n\n#define stbds_shdefault(t, v)  stbds_hmdefault(t,v)\n#define stbds_shdefaults(t, s) stbds_hmdefaults(t,s)\n\n#define stbds_shfree       stbds_hmfree\n#define stbds_shlenu       stbds_hmlenu\n\n#define stbds_shgets(t, k) (*stbds_shgetp(t,k))\n#define stbds_shget(t, k)  (stbds_shgetp(t,k)->value)\n#define stbds_shgetp_null(t,k)  (stbds_shgeti(t,k) == -1 ? NULL : &(t)[stbds_temp((t)-1)])\n#define stbds_shlen        stbds_hmlen\n\ntypedef struct\n{\n  size_t      length;\n  size_t      capacity;\n  void      * hash_table;\n  ptrdiff_t   temp;\n} stbds_array_header;\n\ntypedef struct stbds_string_block\n{\n  struct stbds_string_block *next;\n  char storage[8];\n} stbds_string_block;\n\nstruct stbds_string_arena\n{\n  stbds_string_block *storage;\n  size_t remaining;\n  unsigned char block;\n  unsigned char mode;  // this isn't used by the string arena itself\n};\n\n#define STBDS_HM_BINARY         0\n#define STBDS_HM_STRING         1\n\nenum\n{\n   STBDS_SH_NONE,\n   STBDS_SH_DEFAULT,\n   STBDS_SH_STRDUP,\n   STBDS_SH_ARENA\n};\n\n#ifdef __cplusplus\n// in C we use implicit assignment from these void*-returning functions to T*.\n// in C++ these templates make the same code work\ntemplate<class T> static T * stbds_arrgrowf_wrapper(T *a, size_t elemsize, size_t addlen, size_t min_cap) {\n  return (T*)stbds_arrgrowf((void *)a, elemsize, addlen, min_cap);\n}\ntemplate<class T> static T * stbds_hmget_key_wrapper(T *a, size_t elemsize, void *key, size_t keysize, int mode) {\n  return (T*)stbds_hmget_key((void*)a, elemsize, key, keysize, mode);\n}\ntemplate<class T> static T * stbds_hmget_key_ts_wrapper(T *a, size_t elemsize, void *key, size_t keysize, ptrdiff_t *temp, int mode) {\n  return (T*)stbds_hmget_key_ts((void*)a, elemsize, key, keysize, temp, mode);\n}\ntemplate<class T> static T * stbds_hmput_default_wrapper(T *a, size_t elemsize) {\n  return (T*)stbds_hmput_default((void *)a, elemsize);\n}\ntemplate<class T> static T * stbds_hmput_key_wrapper(T *a, size_t elemsize, void *key, size_t keysize, int mode) {\n  return (T*)stbds_hmput_key((void*)a, elemsize, key, keysize, mode);\n}\ntemplate<class T> static T * stbds_hmdel_key_wrapper(T *a, size_t elemsize, void *key, size_t keysize, size_t keyoffset, int mode){\n  return (T*)stbds_hmdel_key((void*)a, elemsize, key, keysize, keyoffset, mode);\n}\ntemplate<class T> static T * stbds_shmode_func_wrapper(T *, size_t elemsize, int mode) {\n  return (T*)stbds_shmode_func(elemsize, mode);\n}\n#else\n#define stbds_arrgrowf_wrapper            stbds_arrgrowf\n#define stbds_hmget_key_wrapper           stbds_hmget_key\n#define stbds_hmget_key_ts_wrapper        stbds_hmget_key_ts\n#define stbds_hmput_default_wrapper       stbds_hmput_default\n#define stbds_hmput_key_wrapper           stbds_hmput_key\n#define stbds_hmdel_key_wrapper           stbds_hmdel_key\n#define stbds_shmode_func_wrapper(t,e,m)  stbds_shmode_func(e,m)\n#endif\n\n#endif // INCLUDE_STB_DS_H\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//   IMPLEMENTATION\n//\n\n#ifdef STB_DS_IMPLEMENTATION\n#include <assert.h>\n#include <string.h>\n\n#ifndef STBDS_ASSERT\n#define STBDS_ASSERT_WAS_UNDEFINED\n#define STBDS_ASSERT(x)   ((void) 0)\n#endif\n\n#ifdef STBDS_STATISTICS\n#define STBDS_STATS(x)   x\nsize_t stbds_array_grow;\nsize_t stbds_hash_grow;\nsize_t stbds_hash_shrink;\nsize_t stbds_hash_rebuild;\nsize_t stbds_hash_probes;\nsize_t stbds_hash_alloc;\nsize_t stbds_rehash_probes;\nsize_t stbds_rehash_items;\n#else\n#define STBDS_STATS(x)\n#endif\n\n//\n// stbds_arr implementation\n//\n\n//int *prev_allocs[65536];\n//int num_prev;\n\nvoid *stbds_arrgrowf(void *a, size_t elemsize, size_t addlen, size_t min_cap)\n{\n  stbds_array_header temp={0}; // force debugging\n  void *b;\n  size_t min_len = stbds_arrlen(a) + addlen;\n  (void) sizeof(temp);\n\n  // compute the minimum capacity needed\n  if (min_len > min_cap)\n    min_cap = min_len;\n\n  if (min_cap <= stbds_arrcap(a))\n    return a;\n\n  // increase needed capacity to guarantee O(1) amortized\n  if (min_cap < 2 * stbds_arrcap(a))\n    min_cap = 2 * stbds_arrcap(a);\n  else if (min_cap < 4)\n    min_cap = 4;\n\n  //if (num_prev < 65536) if (a) prev_allocs[num_prev++] = (int *) ((char *) a+1);\n  //if (num_prev == 2201)\n  //  num_prev = num_prev;\n  b = STBDS_REALLOC(NULL, (a) ? stbds_header(a) : 0, elemsize * min_cap + sizeof(stbds_array_header));\n  //if (num_prev < 65536) prev_allocs[num_prev++] = (int *) (char *) b;\n  b = (char *) b + sizeof(stbds_array_header);\n  if (a == NULL) {\n    stbds_header(b)->length = 0;\n    stbds_header(b)->hash_table = 0;\n    stbds_header(b)->temp = 0;\n  } else {\n    STBDS_STATS(++stbds_array_grow);\n  }\n  stbds_header(b)->capacity = min_cap;\n\n  return b;\n}\n\nvoid stbds_arrfreef(void *a)\n{\n  STBDS_FREE(NULL, stbds_header(a));\n}\n\n//\n// stbds_hm hash table implementation\n//\n\n#ifdef STBDS_INTERNAL_SMALL_BUCKET\n#define STBDS_BUCKET_LENGTH      4\n#else\n#define STBDS_BUCKET_LENGTH      8\n#endif\n\n#define STBDS_BUCKET_SHIFT      (STBDS_BUCKET_LENGTH == 8 ? 3 : 2)\n#define STBDS_BUCKET_MASK       (STBDS_BUCKET_LENGTH-1)\n#define STBDS_CACHE_LINE_SIZE   64\n\n#define STBDS_ALIGN_FWD(n,a)   (((n) + (a) - 1) & ~((a)-1))\n\ntypedef struct\n{\n   size_t    hash [STBDS_BUCKET_LENGTH];\n   ptrdiff_t index[STBDS_BUCKET_LENGTH];\n} stbds_hash_bucket; // in 32-bit, this is one 64-byte cache line; in 64-bit, each array is one 64-byte cache line\n\ntypedef struct\n{\n  char * temp_key; // this MUST be the first field of the hash table\n  size_t slot_count;\n  size_t used_count;\n  size_t used_count_threshold;\n  size_t used_count_shrink_threshold;\n  size_t tombstone_count;\n  size_t tombstone_count_threshold;\n  size_t seed;\n  size_t slot_count_log2;\n  stbds_string_arena string;\n  stbds_hash_bucket *storage; // not a separate allocation, just 64-byte aligned storage after this struct\n} stbds_hash_index;\n\n#define STBDS_INDEX_EMPTY    -1\n#define STBDS_INDEX_DELETED  -2\n#define STBDS_INDEX_IN_USE(x)  ((x) >= 0)\n\n#define STBDS_HASH_EMPTY      0\n#define STBDS_HASH_DELETED    1\n\nstatic size_t stbds_hash_seed=0x31415926;\n\nvoid stbds_rand_seed(size_t seed)\n{\n  stbds_hash_seed = seed;\n}\n\n#define stbds_load_32_or_64(var, temp, v32, v64_hi, v64_lo)                                          \\\n  temp = v64_lo ^ v32, temp <<= 16, temp <<= 16, temp >>= 16, temp >>= 16, /* discard if 32-bit */   \\\n  var = v64_hi, var <<= 16, var <<= 16,                                    /* discard if 32-bit */   \\\n  var ^= temp ^ v32\n\n#define STBDS_SIZE_T_BITS           ((sizeof (size_t)) * 8)\n\nstatic size_t stbds_probe_position(size_t hash, size_t slot_count, size_t slot_log2)\n{\n  size_t pos;\n  STBDS_NOTUSED(slot_log2);\n  pos = hash & (slot_count-1);\n  #ifdef STBDS_INTERNAL_BUCKET_START\n  pos &= ~STBDS_BUCKET_MASK;\n  #endif\n  return pos;\n}\n\nstatic size_t stbds_log2(size_t slot_count)\n{\n  size_t n=0;\n  while (slot_count > 1) {\n    slot_count >>= 1;\n    ++n;\n  }\n  return n;\n}\n\nstatic stbds_hash_index *stbds_make_hash_index(size_t slot_count, stbds_hash_index *ot)\n{\n  stbds_hash_index *t;\n  t = (stbds_hash_index *) STBDS_REALLOC(NULL,0,(slot_count >> STBDS_BUCKET_SHIFT) * sizeof(stbds_hash_bucket) + sizeof(stbds_hash_index) + STBDS_CACHE_LINE_SIZE-1);\n  t->storage = (stbds_hash_bucket *) STBDS_ALIGN_FWD((size_t) (t+1), STBDS_CACHE_LINE_SIZE);\n  t->slot_count = slot_count;\n  t->slot_count_log2 = stbds_log2(slot_count);\n  t->tombstone_count = 0;\n  t->used_count = 0;\n\n  #if 0 // A1\n  t->used_count_threshold        = slot_count*12/16; // if 12/16th of table is occupied, grow\n  t->tombstone_count_threshold   = slot_count* 2/16; // if tombstones are 2/16th of table, rebuild\n  t->used_count_shrink_threshold = slot_count* 4/16; // if table is only 4/16th full, shrink\n  #elif 1 // A2\n  //t->used_count_threshold        = slot_count*12/16; // if 12/16th of table is occupied, grow\n  //t->tombstone_count_threshold   = slot_count* 3/16; // if tombstones are 3/16th of table, rebuild\n  //t->used_count_shrink_threshold = slot_count* 4/16; // if table is only 4/16th full, shrink\n\n  // compute without overflowing\n  t->used_count_threshold        = slot_count - (slot_count>>2);\n  t->tombstone_count_threshold   = (slot_count>>3) + (slot_count>>4);\n  t->used_count_shrink_threshold = slot_count >> 2;\n\n  #elif 0 // B1\n  t->used_count_threshold        = slot_count*13/16; // if 13/16th of table is occupied, grow\n  t->tombstone_count_threshold   = slot_count* 2/16; // if tombstones are 2/16th of table, rebuild\n  t->used_count_shrink_threshold = slot_count* 5/16; // if table is only 5/16th full, shrink\n  #else // C1\n  t->used_count_threshold        = slot_count*14/16; // if 14/16th of table is occupied, grow\n  t->tombstone_count_threshold   = slot_count* 2/16; // if tombstones are 2/16th of table, rebuild\n  t->used_count_shrink_threshold = slot_count* 6/16; // if table is only 6/16th full, shrink\n  #endif\n  // Following statistics were measured on a Core i7-6700 @ 4.00Ghz, compiled with clang 7.0.1 -O2\n    // Note that the larger tables have high variance as they were run fewer times\n  //     A1            A2          B1           C1\n  //    0.10ms :     0.10ms :     0.10ms :     0.11ms :      2,000 inserts creating 2K table\n  //    0.96ms :     0.95ms :     0.97ms :     1.04ms :     20,000 inserts creating 20K table\n  //   14.48ms :    14.46ms :    10.63ms :    11.00ms :    200,000 inserts creating 200K table\n  //  195.74ms :   196.35ms :   203.69ms :   214.92ms :  2,000,000 inserts creating 2M table\n  // 2193.88ms :  2209.22ms :  2285.54ms :  2437.17ms : 20,000,000 inserts creating 20M table\n  //   65.27ms :    53.77ms :    65.33ms :    65.47ms : 500,000 inserts & deletes in 2K table\n  //   72.78ms :    62.45ms :    71.95ms :    72.85ms : 500,000 inserts & deletes in 20K table\n  //   89.47ms :    77.72ms :    96.49ms :    96.75ms : 500,000 inserts & deletes in 200K table\n  //   97.58ms :    98.14ms :    97.18ms :    97.53ms : 500,000 inserts & deletes in 2M table\n  //  118.61ms :   119.62ms :   120.16ms :   118.86ms : 500,000 inserts & deletes in 20M table\n  //  192.11ms :   194.39ms :   196.38ms :   195.73ms : 500,000 inserts & deletes in 200M table\n\n  if (slot_count <= STBDS_BUCKET_LENGTH)\n    t->used_count_shrink_threshold = 0;\n  // to avoid infinite loop, we need to guarantee that at least one slot is empty and will terminate probes\n  STBDS_ASSERT(t->used_count_threshold + t->tombstone_count_threshold < t->slot_count);\n  STBDS_STATS(++stbds_hash_alloc);\n  if (ot) {\n    t->string = ot->string;\n    // reuse old seed so we can reuse old hashes so below \"copy out old data\" doesn't do any hashing\n    t->seed = ot->seed;\n  } else {\n    size_t a,b,temp;\n    memset(&t->string, 0, sizeof(t->string));\n    t->seed = stbds_hash_seed;\n    // LCG\n    // in 32-bit, a =          2147001325   b =  715136305\n    // in 64-bit, a = 2862933555777941757   b = 3037000493\n    stbds_load_32_or_64(a,temp, 2147001325, 0x27bb2ee6, 0x87b0b0fd);\n    stbds_load_32_or_64(b,temp,  715136305,          0, 0xb504f32d);\n    stbds_hash_seed = stbds_hash_seed  * a + b;\n  }\n\n  {\n    size_t i,j;\n    for (i=0; i < slot_count >> STBDS_BUCKET_SHIFT; ++i) {\n      stbds_hash_bucket *b = &t->storage[i];\n      for (j=0; j < STBDS_BUCKET_LENGTH; ++j)\n        b->hash[j] = STBDS_HASH_EMPTY;\n      for (j=0; j < STBDS_BUCKET_LENGTH; ++j)\n        b->index[j] = STBDS_INDEX_EMPTY;\n    }\n  }\n\n  // copy out the old data, if any\n  if (ot) {\n    size_t i,j;\n    t->used_count = ot->used_count;\n    for (i=0; i < ot->slot_count >> STBDS_BUCKET_SHIFT; ++i) {\n      stbds_hash_bucket *ob = &ot->storage[i];\n      for (j=0; j < STBDS_BUCKET_LENGTH; ++j) {\n        if (STBDS_INDEX_IN_USE(ob->index[j])) {\n          size_t hash = ob->hash[j];\n          size_t pos = stbds_probe_position(hash, t->slot_count, t->slot_count_log2);\n          size_t step = STBDS_BUCKET_LENGTH;\n          STBDS_STATS(++stbds_rehash_items);\n          for (;;) {\n            size_t limit,z;\n            stbds_hash_bucket *bucket;\n            bucket = &t->storage[pos >> STBDS_BUCKET_SHIFT];\n            STBDS_STATS(++stbds_rehash_probes);\n\n            for (z=pos & STBDS_BUCKET_MASK; z < STBDS_BUCKET_LENGTH; ++z) {\n              if (bucket->hash[z] == 0) {\n                bucket->hash[z] = hash;\n                bucket->index[z] = ob->index[j];\n                goto done;\n              }\n            }\n\n            limit = pos & STBDS_BUCKET_MASK;\n            for (z = 0; z < limit; ++z) {\n              if (bucket->hash[z] == 0) {\n                bucket->hash[z] = hash;\n                bucket->index[z] = ob->index[j];\n                goto done;\n              }\n            }\n\n            pos += step;                  // quadratic probing\n            step += STBDS_BUCKET_LENGTH;\n            pos &= (t->slot_count-1);\n          }\n        }\n       done:\n        ;\n      }\n    }\n  }\n\n  return t;\n}\n\n#define STBDS_ROTATE_LEFT(val, n)   (((val) << (n)) | ((val) >> (STBDS_SIZE_T_BITS - (n))))\n#define STBDS_ROTATE_RIGHT(val, n)  (((val) >> (n)) | ((val) << (STBDS_SIZE_T_BITS - (n))))\n\nsize_t stbds_hash_string(char *str, size_t seed)\n{\n  size_t hash = seed;\n  while (*str)\n     hash = STBDS_ROTATE_LEFT(hash, 9) + (unsigned char) *str++;\n\n  // Thomas Wang 64-to-32 bit mix function, hopefully also works in 32 bits\n  hash ^= seed;\n  hash = (~hash) + (hash << 18);\n  hash ^= hash ^ STBDS_ROTATE_RIGHT(hash,31);\n  hash = hash * 21;\n  hash ^= hash ^ STBDS_ROTATE_RIGHT(hash,11);\n  hash += (hash << 6);\n  hash ^= STBDS_ROTATE_RIGHT(hash,22);\n  return hash+seed;\n}\n\n#ifdef STBDS_SIPHASH_2_4\n#define STBDS_SIPHASH_C_ROUNDS 2\n#define STBDS_SIPHASH_D_ROUNDS 4\ntypedef int STBDS_SIPHASH_2_4_can_only_be_used_in_64_bit_builds[sizeof(size_t) == 8 ? 1 : -1];\n#endif\n\n#ifndef STBDS_SIPHASH_C_ROUNDS\n#define STBDS_SIPHASH_C_ROUNDS 1\n#endif\n#ifndef STBDS_SIPHASH_D_ROUNDS\n#define STBDS_SIPHASH_D_ROUNDS 1\n#endif\n\n#ifdef _MSC_VER\n#pragma warning(push)\n#pragma warning(disable:4127) // conditional expression is constant, for do..while(0) and sizeof()==\n#endif\n\nstatic size_t stbds_siphash_bytes(void *p, size_t len, size_t seed)\n{\n  unsigned char *d = (unsigned char *) p;\n  size_t i,j;\n  size_t v0,v1,v2,v3, data;\n\n  // hash that works on 32- or 64-bit registers without knowing which we have\n  // (computes different results on 32-bit and 64-bit platform)\n  // derived from siphash, but on 32-bit platforms very different as it uses 4 32-bit state not 4 64-bit\n  v0 = ((((size_t) 0x736f6d65 << 16) << 16) + 0x70736575) ^  seed;\n  v1 = ((((size_t) 0x646f7261 << 16) << 16) + 0x6e646f6d) ^ ~seed;\n  v2 = ((((size_t) 0x6c796765 << 16) << 16) + 0x6e657261) ^  seed;\n  v3 = ((((size_t) 0x74656462 << 16) << 16) + 0x79746573) ^ ~seed;\n\n  #ifdef STBDS_TEST_SIPHASH_2_4\n  // hardcoded with key material in the siphash test vectors\n  v0 ^= 0x0706050403020100ull ^  seed;\n  v1 ^= 0x0f0e0d0c0b0a0908ull ^ ~seed;\n  v2 ^= 0x0706050403020100ull ^  seed;\n  v3 ^= 0x0f0e0d0c0b0a0908ull ^ ~seed;\n  #endif\n\n  #define STBDS_SIPROUND() \\\n    do {                   \\\n      v0 += v1; v1 = STBDS_ROTATE_LEFT(v1, 13);  v1 ^= v0; v0 = STBDS_ROTATE_LEFT(v0,STBDS_SIZE_T_BITS/2); \\\n      v2 += v3; v3 = STBDS_ROTATE_LEFT(v3, 16);  v3 ^= v2;                                                 \\\n      v2 += v1; v1 = STBDS_ROTATE_LEFT(v1, 17);  v1 ^= v2; v2 = STBDS_ROTATE_LEFT(v2,STBDS_SIZE_T_BITS/2); \\\n      v0 += v3; v3 = STBDS_ROTATE_LEFT(v3, 21);  v3 ^= v0;                                                 \\\n    } while (0)\n\n  for (i=0; i+sizeof(size_t) <= len; i += sizeof(size_t), d += sizeof(size_t)) {\n    data = d[0] | (d[1] << 8) | (d[2] << 16) | (d[3] << 24);\n    data |= (size_t) (d[4] | (d[5] << 8) | (d[6] << 16) | (d[7] << 24)) << 16 << 16; // discarded if size_t == 4\n\n    v3 ^= data;\n    for (j=0; j < STBDS_SIPHASH_C_ROUNDS; ++j)\n      STBDS_SIPROUND();\n    v0 ^= data;\n  }\n  data = len << (STBDS_SIZE_T_BITS-8);\n  switch (len - i) {\n    case 7: data |= ((size_t) d[6] << 24) << 24; // fall through\n    case 6: data |= ((size_t) d[5] << 20) << 20; // fall through\n    case 5: data |= ((size_t) d[4] << 16) << 16; // fall through\n    case 4: data |= (d[3] << 24); // fall through\n    case 3: data |= (d[2] << 16); // fall through\n    case 2: data |= (d[1] << 8); // fall through\n    case 1: data |= d[0]; // fall through\n    case 0: break;\n  }\n  v3 ^= data;\n  for (j=0; j < STBDS_SIPHASH_C_ROUNDS; ++j)\n    STBDS_SIPROUND();\n  v0 ^= data;\n  v2 ^= 0xff;\n  for (j=0; j < STBDS_SIPHASH_D_ROUNDS; ++j)\n    STBDS_SIPROUND();\n\n#ifdef STBDS_SIPHASH_2_4\n  return v0^v1^v2^v3;\n#else\n  return v1^v2^v3; // slightly stronger since v0^v3 in above cancels out final round operation? I tweeted at the authors of SipHash about this but they didn't reply\n#endif\n}\n\nsize_t stbds_hash_bytes(void *p, size_t len, size_t seed)\n{\n#ifdef STBDS_SIPHASH_2_4\n  return stbds_siphash_bytes(p,len,seed);\n#else\n  unsigned char *d = (unsigned char *) p;\n\n  if (len == 4) {\n    unsigned int hash = d[0] | (d[1] << 8) | (d[2] << 16) | (d[3] << 24);\n    #if 0\n    // HASH32-A  Bob Jenkin's hash function w/o large constants\n    hash ^= seed;\n    hash -= (hash<<6);\n    hash ^= (hash>>17);\n    hash -= (hash<<9);\n    hash ^= seed;\n    hash ^= (hash<<4);\n    hash -= (hash<<3);\n    hash ^= (hash<<10);\n    hash ^= (hash>>15);\n    #elif 1\n    // HASH32-BB  Bob Jenkin's presumably-accidental version of Thomas Wang hash with rotates turned into shifts.\n    // Note that converting these back to rotates makes it run a lot slower, presumably due to collisions, so I'm\n    // not really sure what's going on.\n    hash ^= seed;\n    hash = (hash ^ 61) ^ (hash >> 16);\n    hash = hash + (hash << 3);\n    hash = hash ^ (hash >> 4);\n    hash = hash * 0x27d4eb2d;\n    hash ^= seed;\n    hash = hash ^ (hash >> 15);\n    #else  // HASH32-C   -  Murmur3\n    hash ^= seed;\n    hash *= 0xcc9e2d51;\n    hash = (hash << 17) | (hash >> 15);\n    hash *= 0x1b873593;\n    hash ^= seed;\n    hash = (hash << 19) | (hash >> 13);\n    hash = hash*5 + 0xe6546b64;\n    hash ^= hash >> 16;\n    hash *= 0x85ebca6b;\n    hash ^= seed;\n    hash ^= hash >> 13;\n    hash *= 0xc2b2ae35;\n    hash ^= hash >> 16;\n    #endif\n    // Following statistics were measured on a Core i7-6700 @ 4.00Ghz, compiled with clang 7.0.1 -O2\n    // Note that the larger tables have high variance as they were run fewer times\n    //  HASH32-A   //  HASH32-BB  //  HASH32-C\n    //    0.10ms   //    0.10ms   //    0.10ms :      2,000 inserts creating 2K table\n    //    0.96ms   //    0.95ms   //    0.99ms :     20,000 inserts creating 20K table\n    //   14.69ms   //   14.43ms   //   14.97ms :    200,000 inserts creating 200K table\n    //  199.99ms   //  195.36ms   //  202.05ms :  2,000,000 inserts creating 2M table\n    // 2234.84ms   // 2187.74ms   // 2240.38ms : 20,000,000 inserts creating 20M table\n    //   55.68ms   //   53.72ms   //   57.31ms : 500,000 inserts & deletes in 2K table\n    //   63.43ms   //   61.99ms   //   65.73ms : 500,000 inserts & deletes in 20K table\n    //   80.04ms   //   77.96ms   //   81.83ms : 500,000 inserts & deletes in 200K table\n    //  100.42ms   //   97.40ms   //  102.39ms : 500,000 inserts & deletes in 2M table\n    //  119.71ms   //  120.59ms   //  121.63ms : 500,000 inserts & deletes in 20M table\n    //  185.28ms   //  195.15ms   //  187.74ms : 500,000 inserts & deletes in 200M table\n    //   15.58ms   //   14.79ms   //   15.52ms : 200,000 inserts creating 200K table with varying key spacing\n\n    return (((size_t) hash << 16 << 16) | hash) ^ seed;\n  } else if (len == 8 && sizeof(size_t) == 8) {\n    size_t hash = d[0] | (d[1] << 8) | (d[2] << 16) | (d[3] << 24);\n    hash |= (size_t) (d[4] | (d[5] << 8) | (d[6] << 16) | (d[7] << 24)) << 16 << 16; // avoid warning if size_t == 4\n    hash ^= seed;\n    hash = (~hash) + (hash << 21);\n    hash ^= STBDS_ROTATE_RIGHT(hash,24);\n    hash *= 265;\n    hash ^= STBDS_ROTATE_RIGHT(hash,14);\n    hash ^= seed;\n    hash *= 21;\n    hash ^= STBDS_ROTATE_RIGHT(hash,28);\n    hash += (hash << 31);\n    hash = (~hash) + (hash << 18);\n    return hash;\n  } else {\n    return stbds_siphash_bytes(p,len,seed);\n  }\n#endif\n}\n#ifdef _MSC_VER\n#pragma warning(pop)\n#endif\n\n\nstatic int stbds_is_key_equal(void *a, size_t elemsize, void *key, size_t keysize, size_t keyoffset, int mode, size_t i)\n{\n  if (mode >= STBDS_HM_STRING)\n    return 0==strcmp((char *) key, * (char **) ((char *) a + elemsize*i + keyoffset));\n  else\n    return 0==memcmp(key, (char *) a + elemsize*i + keyoffset, keysize);\n}\n\n#define STBDS_HASH_TO_ARR(x,elemsize) ((char*) (x) - (elemsize))\n#define STBDS_ARR_TO_HASH(x,elemsize) ((char*) (x) + (elemsize))\n\n#define stbds_hash_table(a)  ((stbds_hash_index *) stbds_header(a)->hash_table)\n\nvoid stbds_hmfree_func(void *a, size_t elemsize)\n{\n  if (a == NULL) return;\n  if (stbds_hash_table(a) != NULL) {\n    if (stbds_hash_table(a)->string.mode == STBDS_SH_STRDUP) {\n      size_t i;\n      // skip 0th element, which is default\n      for (i=1; i < stbds_header(a)->length; ++i)\n        STBDS_FREE(NULL, *(char**) ((char *) a + elemsize*i));\n    }\n    stbds_strreset(&stbds_hash_table(a)->string);\n  }\n  STBDS_FREE(NULL, stbds_header(a)->hash_table);\n  STBDS_FREE(NULL, stbds_header(a));\n}\n\nstatic ptrdiff_t stbds_hm_find_slot(void *a, size_t elemsize, void *key, size_t keysize, size_t keyoffset, int mode)\n{\n  void *raw_a = STBDS_HASH_TO_ARR(a,elemsize);\n  stbds_hash_index *table = stbds_hash_table(raw_a);\n  size_t hash = mode >= STBDS_HM_STRING ? stbds_hash_string((char*)key,table->seed) : stbds_hash_bytes(key, keysize,table->seed);\n  size_t step = STBDS_BUCKET_LENGTH;\n  size_t limit,i;\n  size_t pos;\n  stbds_hash_bucket *bucket;\n\n  if (hash < 2) hash += 2; // stored hash values are forbidden from being 0, so we can detect empty slots\n\n  pos = stbds_probe_position(hash, table->slot_count, table->slot_count_log2);\n\n  for (;;) {\n    STBDS_STATS(++stbds_hash_probes);\n    bucket = &table->storage[pos >> STBDS_BUCKET_SHIFT];\n\n    // start searching from pos to end of bucket, this should help performance on small hash tables that fit in cache\n    for (i=pos & STBDS_BUCKET_MASK; i < STBDS_BUCKET_LENGTH; ++i) {\n      if (bucket->hash[i] == hash) {\n        if (stbds_is_key_equal(a, elemsize, key, keysize, keyoffset, mode, bucket->index[i])) {\n          return (pos & ~STBDS_BUCKET_MASK)+i;\n        }\n      } else if (bucket->hash[i] == STBDS_HASH_EMPTY) {\n        return -1;\n      }\n    }\n\n    // search from beginning of bucket to pos\n    limit = pos & STBDS_BUCKET_MASK;\n    for (i = 0; i < limit; ++i) {\n      if (bucket->hash[i] == hash) {\n        if (stbds_is_key_equal(a, elemsize, key, keysize, keyoffset, mode, bucket->index[i])) {\n          return (pos & ~STBDS_BUCKET_MASK)+i;\n        }\n      } else if (bucket->hash[i] == STBDS_HASH_EMPTY) {\n        return -1;\n      }\n    }\n\n    // quadratic probing\n    pos += step;\n    step += STBDS_BUCKET_LENGTH;\n    pos &= (table->slot_count-1);\n  }\n  /* NOTREACHED */\n}\n\nvoid * stbds_hmget_key_ts(void *a, size_t elemsize, void *key, size_t keysize, ptrdiff_t *temp, int mode)\n{\n  size_t keyoffset = 0;\n  if (a == NULL) {\n    // make it non-empty so we can return a temp\n    a = stbds_arrgrowf(0, elemsize, 0, 1);\n    stbds_header(a)->length += 1;\n    memset(a, 0, elemsize);\n    *temp = STBDS_INDEX_EMPTY;\n    // adjust a to point after the default element\n    return STBDS_ARR_TO_HASH(a,elemsize);\n  } else {\n    stbds_hash_index *table;\n    void *raw_a = STBDS_HASH_TO_ARR(a,elemsize);\n    // adjust a to point to the default element\n    table = (stbds_hash_index *) stbds_header(raw_a)->hash_table;\n    if (table == 0) {\n      *temp = -1;\n    } else {\n      ptrdiff_t slot = stbds_hm_find_slot(a, elemsize, key, keysize, keyoffset, mode);\n      if (slot < 0) {\n        *temp = STBDS_INDEX_EMPTY;\n      } else {\n        stbds_hash_bucket *b = &table->storage[slot >> STBDS_BUCKET_SHIFT];\n        *temp = b->index[slot & STBDS_BUCKET_MASK];\n      }\n    }\n    return a;\n  }\n}\n\nvoid * stbds_hmget_key(void *a, size_t elemsize, void *key, size_t keysize, int mode)\n{\n  ptrdiff_t temp;\n  void *p = stbds_hmget_key_ts(a, elemsize, key, keysize, &temp, mode);\n  stbds_temp(STBDS_HASH_TO_ARR(p,elemsize)) = temp;\n  return p;\n}\n\nvoid * stbds_hmput_default(void *a, size_t elemsize)\n{\n  // three cases:\n  //   a is NULL <- allocate\n  //   a has a hash table but no entries, because of shmode <- grow\n  //   a has entries <- do nothing\n  if (a == NULL || stbds_header(STBDS_HASH_TO_ARR(a,elemsize))->length == 0) {\n    a = stbds_arrgrowf(a ? STBDS_HASH_TO_ARR(a,elemsize) : NULL, elemsize, 0, 1);\n    stbds_header(a)->length += 1;\n    memset(a, 0, elemsize);\n    a=STBDS_ARR_TO_HASH(a,elemsize);\n  }\n  return a;\n}\n\nstatic char *stbds_strdup(char *str);\n\nvoid *stbds_hmput_key(void *a, size_t elemsize, void *key, size_t keysize, int mode)\n{\n  size_t keyoffset=0;\n  void *raw_a;\n  stbds_hash_index *table;\n\n  if (a == NULL) {\n    a = stbds_arrgrowf(0, elemsize, 0, 1);\n    memset(a, 0, elemsize);\n    stbds_header(a)->length += 1;\n    // adjust a to point AFTER the default element\n    a = STBDS_ARR_TO_HASH(a,elemsize);\n  }\n\n  // adjust a to point to the default element\n  raw_a = a;\n  a = STBDS_HASH_TO_ARR(a,elemsize);\n\n  table = (stbds_hash_index *) stbds_header(a)->hash_table;\n\n  if (table == NULL || table->used_count >= table->used_count_threshold) {\n    stbds_hash_index *nt;\n    size_t slot_count;\n\n    slot_count = (table == NULL) ? STBDS_BUCKET_LENGTH : table->slot_count*2;\n    nt = stbds_make_hash_index(slot_count, table);\n    if (table)\n      STBDS_FREE(NULL, table);\n    else\n      nt->string.mode = mode >= STBDS_HM_STRING ? STBDS_SH_DEFAULT : 0;\n    stbds_header(a)->hash_table = table = nt;\n    STBDS_STATS(++stbds_hash_grow);\n  }\n\n  // we iterate hash table explicitly because we want to track if we saw a tombstone\n  {\n    size_t hash = mode >= STBDS_HM_STRING ? stbds_hash_string((char*)key,table->seed) : stbds_hash_bytes(key, keysize,table->seed);\n    size_t step = STBDS_BUCKET_LENGTH;\n    size_t pos;\n    ptrdiff_t tombstone = -1;\n    stbds_hash_bucket *bucket;\n\n    // stored hash values are forbidden from being 0, so we can detect empty slots to early out quickly\n    if (hash < 2) hash += 2;\n\n    pos = stbds_probe_position(hash, table->slot_count, table->slot_count_log2);\n\n    for (;;) {\n      size_t limit, i;\n      STBDS_STATS(++stbds_hash_probes);\n      bucket = &table->storage[pos >> STBDS_BUCKET_SHIFT];\n\n      // start searching from pos to end of bucket\n      for (i=pos & STBDS_BUCKET_MASK; i < STBDS_BUCKET_LENGTH; ++i) {\n        if (bucket->hash[i] == hash) {\n          if (stbds_is_key_equal(raw_a, elemsize, key, keysize, keyoffset, mode, bucket->index[i])) {\n            stbds_temp(a) = bucket->index[i];\n            if (mode >= STBDS_HM_STRING)\n              stbds_temp_key(a) = * (char **) ((char *) raw_a + elemsize*bucket->index[i] + keyoffset);\n            return STBDS_ARR_TO_HASH(a,elemsize);\n          }\n        } else if (bucket->hash[i] == 0) {\n          pos = (pos & ~STBDS_BUCKET_MASK) + i;\n          goto found_empty_slot;\n        } else if (tombstone < 0) {\n          if (bucket->index[i] == STBDS_INDEX_DELETED)\n            tombstone = (ptrdiff_t) ((pos & ~STBDS_BUCKET_MASK) + i);\n        }\n      }\n\n      // search from beginning of bucket to pos\n      limit = pos & STBDS_BUCKET_MASK;\n      for (i = 0; i < limit; ++i) {\n        if (bucket->hash[i] == hash) {\n          if (stbds_is_key_equal(raw_a, elemsize, key, keysize, keyoffset, mode, bucket->index[i])) {\n            stbds_temp(a) = bucket->index[i];\n            return STBDS_ARR_TO_HASH(a,elemsize);\n          }\n        } else if (bucket->hash[i] == 0) {\n          pos = (pos & ~STBDS_BUCKET_MASK) + i;\n          goto found_empty_slot;\n        } else if (tombstone < 0) {\n          if (bucket->index[i] == STBDS_INDEX_DELETED)\n            tombstone = (ptrdiff_t) ((pos & ~STBDS_BUCKET_MASK) + i);\n        }\n      }\n\n      // quadratic probing\n      pos += step;\n      step += STBDS_BUCKET_LENGTH;\n      pos &= (table->slot_count-1);\n    }\n   found_empty_slot:\n    if (tombstone >= 0) {\n      pos = tombstone;\n      --table->tombstone_count;\n    }\n    ++table->used_count;\n\n    {\n      ptrdiff_t i = (ptrdiff_t) stbds_arrlen(a);\n      // we want to do stbds_arraddn(1), but we can't use the macros since we don't have something of the right type\n      if ((size_t) i+1 > stbds_arrcap(a))\n        *(void **) &a = stbds_arrgrowf(a, elemsize, 1, 0);\n      raw_a = STBDS_ARR_TO_HASH(a,elemsize);\n\n      STBDS_ASSERT((size_t) i+1 <= stbds_arrcap(a));\n      stbds_header(a)->length = i+1;\n      bucket = &table->storage[pos >> STBDS_BUCKET_SHIFT];\n      bucket->hash[pos & STBDS_BUCKET_MASK] = hash;\n      bucket->index[pos & STBDS_BUCKET_MASK] = i-1;\n      stbds_temp(a) = i-1;\n\n      switch (table->string.mode) {\n         case STBDS_SH_STRDUP:  stbds_temp_key(a) = *(char **) ((char *) a + elemsize*i) = stbds_strdup((char*) key); break;\n         case STBDS_SH_ARENA:   stbds_temp_key(a) = *(char **) ((char *) a + elemsize*i) = stbds_stralloc(&table->string, (char*)key); break;\n         case STBDS_SH_DEFAULT: stbds_temp_key(a) = *(char **) ((char *) a + elemsize*i) = (char *) key; break;\n         default:                memcpy((char *) a + elemsize*i, key, keysize); break;\n      }\n    }\n    return STBDS_ARR_TO_HASH(a,elemsize);\n  }\n}\n\nvoid * stbds_shmode_func(size_t elemsize, int mode)\n{\n  void *a = stbds_arrgrowf(0, elemsize, 0, 1);\n  stbds_hash_index *h;\n  memset(a, 0, elemsize);\n  stbds_header(a)->length = 1;\n  stbds_header(a)->hash_table = h = (stbds_hash_index *) stbds_make_hash_index(STBDS_BUCKET_LENGTH, NULL);\n  h->string.mode = (unsigned char) mode;\n  return STBDS_ARR_TO_HASH(a,elemsize);\n}\n\nvoid * stbds_hmdel_key(void *a, size_t elemsize, void *key, size_t keysize, size_t keyoffset, int mode)\n{\n  if (a == NULL) {\n    return 0;\n  } else {\n    stbds_hash_index *table;\n    void *raw_a = STBDS_HASH_TO_ARR(a,elemsize);\n    table = (stbds_hash_index *) stbds_header(raw_a)->hash_table;\n    stbds_temp(raw_a) = 0;\n    if (table == 0) {\n      return a;\n    } else {\n      ptrdiff_t slot;\n      slot = stbds_hm_find_slot(a, elemsize, key, keysize, keyoffset, mode);\n      if (slot < 0)\n        return a;\n      else {\n        stbds_hash_bucket *b = &table->storage[slot >> STBDS_BUCKET_SHIFT];\n        int i = slot & STBDS_BUCKET_MASK;\n        ptrdiff_t old_index = b->index[i];\n        ptrdiff_t final_index = (ptrdiff_t) stbds_arrlen(raw_a)-1-1; // minus one for the raw_a vs a, and minus one for 'last'\n        STBDS_ASSERT(slot < (ptrdiff_t) table->slot_count);\n        --table->used_count;\n        ++table->tombstone_count;\n        stbds_temp(raw_a) = 1;\n        STBDS_ASSERT(table->used_count >= 0);\n        //STBDS_ASSERT(table->tombstone_count < table->slot_count/4);\n        b->hash[i] = STBDS_HASH_DELETED;\n        b->index[i] = STBDS_INDEX_DELETED;\n\n        if (mode == STBDS_HM_STRING && table->string.mode == STBDS_SH_STRDUP)\n          STBDS_FREE(NULL, *(char**) ((char *) a+elemsize*old_index));\n\n        // if indices are the same, memcpy is a no-op, but back-pointer-fixup will fail, so skip\n        if (old_index != final_index) {\n          // swap delete\n          memmove((char*) a + elemsize*old_index, (char*) a + elemsize*final_index, elemsize);\n\n          // now find the slot for the last element\n          if (mode == STBDS_HM_STRING)\n            slot = stbds_hm_find_slot(a, elemsize, *(char**) ((char *) a+elemsize*old_index + keyoffset), keysize, keyoffset, mode);\n          else\n            slot = stbds_hm_find_slot(a, elemsize,  (char* ) a+elemsize*old_index + keyoffset, keysize, keyoffset, mode);\n          STBDS_ASSERT(slot >= 0);\n          b = &table->storage[slot >> STBDS_BUCKET_SHIFT];\n          i = slot & STBDS_BUCKET_MASK;\n          STBDS_ASSERT(b->index[i] == final_index);\n          b->index[i] = old_index;\n        }\n        stbds_header(raw_a)->length -= 1;\n\n        if (table->used_count < table->used_count_shrink_threshold && table->slot_count > STBDS_BUCKET_LENGTH) {\n          stbds_header(raw_a)->hash_table = stbds_make_hash_index(table->slot_count>>1, table);\n          STBDS_FREE(NULL, table);\n          STBDS_STATS(++stbds_hash_shrink);\n        } else if (table->tombstone_count > table->tombstone_count_threshold) {\n          stbds_header(raw_a)->hash_table = stbds_make_hash_index(table->slot_count   , table);\n          STBDS_FREE(NULL, table);\n          STBDS_STATS(++stbds_hash_rebuild);\n        }\n\n        return a;\n      }\n    }\n  }\n  /* NOTREACHED */\n}\n\nstatic char *stbds_strdup(char *str)\n{\n  // to keep replaceable allocator simple, we don't want to use strdup.\n  // rolling our own also avoids problem of strdup vs _strdup\n  size_t len = strlen(str)+1;\n  char *p = (char*) STBDS_REALLOC(NULL, 0, len);\n  memmove(p, str, len);\n  return p;\n}\n\n#ifndef STBDS_STRING_ARENA_BLOCKSIZE_MIN\n#define STBDS_STRING_ARENA_BLOCKSIZE_MIN  512u\n#endif\n#ifndef STBDS_STRING_ARENA_BLOCKSIZE_MAX\n#define STBDS_STRING_ARENA_BLOCKSIZE_MAX  (1u<<20)\n#endif\n\nchar *stbds_stralloc(stbds_string_arena *a, char *str)\n{\n  char *p;\n  size_t len = strlen(str)+1;\n  if (len > a->remaining) {\n    // compute the next blocksize\n    size_t blocksize = a->block;\n\n    // size is 512, 512, 1024, 1024, 2048, 2048, 4096, 4096, etc., so that\n    // there are log(SIZE) allocations to free when we destroy the table\n    blocksize = (size_t) (STBDS_STRING_ARENA_BLOCKSIZE_MIN) << (blocksize>>1);\n\n    // if size is under 1M, advance to next blocktype\n    if (blocksize < (size_t)(STBDS_STRING_ARENA_BLOCKSIZE_MAX))\n      ++a->block;\n\n    if (len > blocksize) {\n      // if string is larger than blocksize, then just allocate the full size.\n      // note that we still advance string_block so block size will continue\n      // increasing, so e.g. if somebody only calls this with 1000-long strings,\n      // eventually the arena will start doubling and handling those as well\n      stbds_string_block *sb = (stbds_string_block *) STBDS_REALLOC(NULL, 0, sizeof(*sb)-8 + len);\n      memmove(sb->storage, str, len);\n      if (a->storage) {\n        // insert it after the first element, so that we don't waste the space there\n        sb->next = a->storage->next;\n        a->storage->next = sb;\n      } else {\n        sb->next = 0;\n        a->storage = sb;\n        a->remaining = 0; // this is redundant, but good for clarity\n      }\n      return sb->storage;\n    } else {\n      stbds_string_block *sb = (stbds_string_block *) STBDS_REALLOC(NULL, 0, sizeof(*sb)-8 + blocksize);\n      sb->next = a->storage;\n      a->storage = sb;\n      a->remaining = blocksize;\n    }\n  }\n\n  STBDS_ASSERT(len <= a->remaining);\n  p = a->storage->storage + a->remaining - len;\n  a->remaining -= len;\n  memmove(p, str, len);\n  return p;\n}\n\nvoid stbds_strreset(stbds_string_arena *a)\n{\n  stbds_string_block *x,*y;\n  x = a->storage;\n  while (x) {\n    y = x->next;\n    STBDS_FREE(NULL, x);\n    x = y;\n  }\n  memset(a, 0, sizeof(*a));\n}\n\n#endif\n\n//////////////////////////////////////////////////////////////////////////////\n//\n//   UNIT TESTS\n//\n\n#ifdef STBDS_UNIT_TESTS\n#include <stdio.h>\n#ifdef STBDS_ASSERT_WAS_UNDEFINED\n#undef STBDS_ASSERT\n#endif\n#ifndef STBDS_ASSERT\n#define STBDS_ASSERT assert\n#include <assert.h>\n#endif\n\ntypedef struct { int key,b,c,d; } stbds_struct;\ntypedef struct { int key[2],b,c,d; } stbds_struct2;\n\nstatic char buffer[256];\nchar *strkey(int n)\n{\n#if defined(_WIN32) && defined(__STDC_WANT_SECURE_LIB__)\n   sprintf_s(buffer, sizeof(buffer), \"test_%d\", n);\n#else\n   sprintf(buffer, \"test_%d\", n);\n#endif\n   return buffer;\n}\n\nvoid stbds_unit_tests(void)\n{\n#if defined(_MSC_VER) && _MSC_VER <= 1200 && defined(__cplusplus)\n  // VC6 C++ doesn't like the template<> trick on unnamed structures, so do nothing!\n  STBDS_ASSERT(0);\n#else\n  const int testsize = 100000;\n  const int testsize2 = testsize/20;\n  int *arr=NULL;\n  struct { int   key;        int value; }  *intmap  = NULL;\n  struct { char *key;        int value; }  *strmap  = NULL, s;\n  struct { stbds_struct key; int value; }  *map     = NULL;\n  stbds_struct                             *map2    = NULL;\n  stbds_struct2                            *map3    = NULL;\n  stbds_string_arena                        sa      = { 0 };\n  int key3[2] = { 1,2 };\n  ptrdiff_t temp;\n\n  int i,j;\n\n  STBDS_ASSERT(arrlen(arr)==0);\n  for (i=0; i < 20000; i += 50) {\n    for (j=0; j < i; ++j)\n      arrpush(arr,j);\n    arrfree(arr);\n  }\n\n  for (i=0; i < 4; ++i) {\n    arrpush(arr,1); arrpush(arr,2); arrpush(arr,3); arrpush(arr,4);\n    arrdel(arr,i);\n    arrfree(arr);\n    arrpush(arr,1); arrpush(arr,2); arrpush(arr,3); arrpush(arr,4);\n    arrdelswap(arr,i);\n    arrfree(arr);\n  }\n\n  for (i=0; i < 5; ++i) {\n    arrpush(arr,1); arrpush(arr,2); arrpush(arr,3); arrpush(arr,4);\n    stbds_arrins(arr,i,5);\n    STBDS_ASSERT(arr[i] == 5);\n    if (i < 4)\n      STBDS_ASSERT(arr[4] == 4);\n    arrfree(arr);\n  }\n\n  i = 1;\n  STBDS_ASSERT(hmgeti(intmap,i) == -1);\n  hmdefault(intmap, -2);\n  STBDS_ASSERT(hmgeti(intmap, i) == -1);\n  STBDS_ASSERT(hmget (intmap, i) == -2);\n  for (i=0; i < testsize; i+=2)\n    hmput(intmap, i, i*5);\n  for (i=0; i < testsize; i+=1) {\n    if (i & 1) STBDS_ASSERT(hmget(intmap, i) == -2 );\n    else       STBDS_ASSERT(hmget(intmap, i) == i*5);\n    if (i & 1) STBDS_ASSERT(hmget_ts(intmap, i, temp) == -2 );\n    else       STBDS_ASSERT(hmget_ts(intmap, i, temp) == i*5);\n  }\n  for (i=0; i < testsize; i+=2)\n    hmput(intmap, i, i*3);\n  for (i=0; i < testsize; i+=1)\n    if (i & 1) STBDS_ASSERT(hmget(intmap, i) == -2 );\n    else       STBDS_ASSERT(hmget(intmap, i) == i*3);\n  for (i=2; i < testsize; i+=4)\n    hmdel(intmap, i); // delete half the entries\n  for (i=0; i < testsize; i+=1)\n    if (i & 3) STBDS_ASSERT(hmget(intmap, i) == -2 );\n    else       STBDS_ASSERT(hmget(intmap, i) == i*3);\n  for (i=0; i < testsize; i+=1)\n    hmdel(intmap, i); // delete the rest of the entries\n  for (i=0; i < testsize; i+=1)\n    STBDS_ASSERT(hmget(intmap, i) == -2 );\n  hmfree(intmap);\n  for (i=0; i < testsize; i+=2)\n    hmput(intmap, i, i*3);\n  hmfree(intmap);\n\n  #if defined(__clang__) || defined(__GNUC__)\n  #ifndef __cplusplus\n  intmap = NULL;\n  hmput(intmap, 15, 7);\n  hmput(intmap, 11, 3);\n  hmput(intmap,  9, 5);\n  STBDS_ASSERT(hmget(intmap, 9) == 5);\n  STBDS_ASSERT(hmget(intmap, 11) == 3);\n  STBDS_ASSERT(hmget(intmap, 15) == 7);\n  #endif\n  #endif\n\n  for (i=0; i < testsize; ++i)\n    stralloc(&sa, strkey(i));\n  strreset(&sa);\n\n  {\n    s.key = \"a\", s.value = 1;\n    shputs(strmap, s);\n    STBDS_ASSERT(*strmap[0].key == 'a');\n    STBDS_ASSERT(strmap[0].key == s.key);\n    STBDS_ASSERT(strmap[0].value == s.value);\n    shfree(strmap);\n  }\n\n  {\n    s.key = \"a\", s.value = 1;\n    sh_new_strdup(strmap);\n    shputs(strmap, s);\n    STBDS_ASSERT(*strmap[0].key == 'a');\n    STBDS_ASSERT(strmap[0].key != s.key);\n    STBDS_ASSERT(strmap[0].value == s.value);\n    shfree(strmap);\n  }\n\n  {\n    s.key = \"a\", s.value = 1;\n    sh_new_arena(strmap);\n    shputs(strmap, s);\n    STBDS_ASSERT(*strmap[0].key == 'a');\n    STBDS_ASSERT(strmap[0].key != s.key);\n    STBDS_ASSERT(strmap[0].value == s.value);\n    shfree(strmap);\n  }\n\n  for (j=0; j < 2; ++j) {\n    STBDS_ASSERT(shgeti(strmap,\"foo\") == -1);\n    if (j == 0)\n      sh_new_strdup(strmap);\n    else\n      sh_new_arena(strmap);\n    STBDS_ASSERT(shgeti(strmap,\"foo\") == -1);\n    shdefault(strmap, -2);\n    STBDS_ASSERT(shgeti(strmap,\"foo\") == -1);\n    for (i=0; i < testsize; i+=2)\n      shput(strmap, strkey(i), i*3);\n    for (i=0; i < testsize; i+=1)\n      if (i & 1) STBDS_ASSERT(shget(strmap, strkey(i)) == -2 );\n      else       STBDS_ASSERT(shget(strmap, strkey(i)) == i*3);\n    for (i=2; i < testsize; i+=4)\n      shdel(strmap, strkey(i)); // delete half the entries\n    for (i=0; i < testsize; i+=1)\n      if (i & 3) STBDS_ASSERT(shget(strmap, strkey(i)) == -2 );\n      else       STBDS_ASSERT(shget(strmap, strkey(i)) == i*3);\n    for (i=0; i < testsize; i+=1)\n      shdel(strmap, strkey(i)); // delete the rest of the entries\n    for (i=0; i < testsize; i+=1)\n      STBDS_ASSERT(shget(strmap, strkey(i)) == -2 );\n    shfree(strmap);\n  }\n\n  {\n    struct { char *key; char value; } *hash = NULL;\n    char name[4] = \"jen\";\n    shput(hash, \"bob\"   , 'h');\n    shput(hash, \"sally\" , 'e');\n    shput(hash, \"fred\"  , 'l');\n    shput(hash, \"jen\"   , 'x');\n    shput(hash, \"doug\"  , 'o');\n\n    shput(hash, name    , 'l');\n    shfree(hash);\n  }\n\n  for (i=0; i < testsize; i += 2) {\n    stbds_struct s = { i,i*2,i*3,i*4 };\n    hmput(map, s, i*5);\n  }\n\n  for (i=0; i < testsize; i += 1) {\n    stbds_struct s = { i,i*2,i*3  ,i*4 };\n    stbds_struct t = { i,i*2,i*3+1,i*4 };\n    if (i & 1) STBDS_ASSERT(hmget(map, s) == 0);\n    else       STBDS_ASSERT(hmget(map, s) == i*5);\n    if (i & 1) STBDS_ASSERT(hmget_ts(map, s, temp) == 0);\n    else       STBDS_ASSERT(hmget_ts(map, s, temp) == i*5);\n    //STBDS_ASSERT(hmget(map, t.key) == 0);\n  }\n\n  for (i=0; i < testsize; i += 2) {\n    stbds_struct s = { i,i*2,i*3,i*4 };\n    hmputs(map2, s);\n  }\n  hmfree(map);\n\n  for (i=0; i < testsize; i += 1) {\n    stbds_struct s = { i,i*2,i*3,i*4 };\n    stbds_struct t = { i,i*2,i*3+1,i*4 };\n    if (i & 1) STBDS_ASSERT(hmgets(map2, s.key).d == 0);\n    else       STBDS_ASSERT(hmgets(map2, s.key).d == i*4);\n    //STBDS_ASSERT(hmgetp(map2, t.key) == 0);\n  }\n  hmfree(map2);\n\n  for (i=0; i < testsize; i += 2) {\n    stbds_struct2 s = { { i,i*2 }, i*3,i*4, i*5 };\n    hmputs(map3, s);\n  }\n  for (i=0; i < testsize; i += 1) {\n    stbds_struct2 s = { { i,i*2}, i*3, i*4, i*5 };\n    stbds_struct2 t = { { i,i*2}, i*3+1, i*4, i*5 };\n    if (i & 1) STBDS_ASSERT(hmgets(map3, s.key).d == 0);\n    else       STBDS_ASSERT(hmgets(map3, s.key).d == i*5);\n    //STBDS_ASSERT(hmgetp(map3, t.key) == 0);\n  }\n#endif\n}\n#endif\n\n\n/*\n------------------------------------------------------------------------------\nThis software is available under 2 licenses -- choose whichever you prefer.\n------------------------------------------------------------------------------\nALTERNATIVE A - MIT License\nCopyright (c) 2019 Sean Barrett\nPermission is hereby granted, free of charge, to any person obtaining a copy of\nthis software and associated documentation files (the \"Software\"), to deal in\nthe Software without restriction, including without limitation the rights to\nuse, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\nof the Software, and to permit persons to whom the Software is furnished to do\nso, subject to the following conditions:\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n------------------------------------------------------------------------------\nALTERNATIVE B - Public Domain (www.unlicense.org)\nThis is free and unencumbered software released into the public domain.\nAnyone is free to copy, modify, publish, use, compile, sell, or distribute this\nsoftware, either in source code form or as a compiled binary, for any purpose,\ncommercial or non-commercial, and by any means.\nIn jurisdictions that recognize copyright laws, the author or authors of this\nsoftware dedicate any and all copyright interest in the software to the public\ndomain. We make this dedication for the benefit of the public at large and to\nthe detriment of our heirs and successors. We intend this dedication to be an\novert act of relinquishment in perpetuity of all present and future rights to\nthis software under copyright law.\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\nACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n------------------------------------------------------------------------------\n*/";

const char *SRC_SDSALLOC_H = "/* SDSLib 2.0 -- A C dynamic strings library\n *\n * Copyright (c) 2006-2015, Salvatore Sanfilippo <antirez at gmail dot com>\n * Copyright (c) 2015, Oran Agra\n * Copyright (c) 2015, Redis Labs, Inc\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n/* SDS allocator selection.\n *\n * This file is used in order to change the SDS allocator at compile time.\n * Just define the following defines to what you want to use. Also add\n * the include of your alternate allocator if needed (not needed in order\n * to use the default libc allocator). */\n\n#define s_malloc malloc\n#define s_realloc realloc\n#define s_free free\n";

#endif
